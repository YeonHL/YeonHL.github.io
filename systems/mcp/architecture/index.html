<!doctype html><html lang=ko dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="MCP의 아키텍처 및 통신 과정을 이해하면서 내부 동작과 철학을 살펴보겠습니다."><meta name=keywords content="MCP"><title>MCP 아키텍처</title><link rel=canonical href=https://yeonhl.github.io/systems/mcp/architecture/><link rel=stylesheet href=/scss/style.min.b280f8d12f17a311189fd98d471033ed63d849df69cb3936772f719d7eee3677.css><meta property='og:title' content="MCP 아키텍처"><meta property='og:description' content="MCP의 아키텍처 및 통신 과정을 이해하면서 내부 동작과 철학을 살펴보겠습니다."><meta property='og:url' content='https://yeonhl.github.io/systems/mcp/architecture/'><meta property='og:site_name' content='연호의 블로그'><meta property='og:type' content='article'><meta property='article:section' content='Systems'><meta property='article:tag' content='MCP'><meta property='article:published_time' content='2025-08-14T19:03:00+00:00'><meta property='article:modified_time' content='2025-09-16T00:00:00+00:00'><meta name=twitter:title content="MCP 아키텍처"><meta name=twitter:description content="MCP의 아키텍처 및 통신 과정을 이해하면서 내부 동작과 철학을 살펴보겠습니다."><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="메뉴 여닫기">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_c68a00bbf16dac8.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🖥️</span></figure><div class=site-meta><h1 class=site-name><a href=/>연호의 블로그</a></h1><h2 class=site-description>알고 사용하는 엔지니어가 되자</h2></div></header><ol class=menu-social><li><a href=https://github.com/YeonHL target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>홈</span></a></li><li><a href=/p/introduce/><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-book"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 19a9 9 0 019 0 9 9 0 019 0"/><path d="M3 6a9 9 0 019 0 9 9 0 019 0"/><path d="M3 6v13"/><path d="M12 6v13"/><path d="M21 6v13"/></svg>
<span>소개</span></a></li><li class=current><a href=/systems/><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-settings"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10.325 4.317c.426-1.756 2.924-1.756 3.35.0a1.724 1.724.0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724.0 001.065 2.572c1.756.426 1.756 2.924.0 3.35a1.724 1.724.0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724.0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35.0a1.724 1.724.0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724.0 00-1.065-2.572c-1.756-.426-1.756-2.924.0-3.35a1.724 1.724.0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37 1 .608 2.296.07 2.572-1.065z"/><path d="M9 12a3 3 0 106 0 3 3 0 00-6 0"/></svg>
<span>시스템</span></a></li><li><a href=/theories/><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-books"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 4m0 1a1 1 0 011-1h2a1 1 0 011 1v14a1 1 0 01-1 1H6a1 1 0 01-1-1z"/><path d="M9 4m0 1a1 1 0 011-1h2a1 1 0 011 1v14a1 1 0 01-1 1h-2a1 1 0 01-1-1z"/><path d="M5 8h4"/><path d="M9 16h4"/><path d="M13.803 4.56l2.184-.53c.562-.135 1.133.19 1.282.732l3.695 13.418a1.02 1.02.0 01-.634 1.219l-.133.041-2.184.53c-.562.135-1.133-.19-1.282-.732L13.036 5.82a1.02 1.02.0 01.634-1.219l.133-.041z"/><path d="M14 9l4-1"/><path d="M16 16l3.923-.98"/></svg>
<span>이론</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>보관함</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>검색</span></a></li><li class=menu-bottom-section><ol class=menu><li id=i18n-switch><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language title=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://yeonhl.github.io/ selected>Korean</option><option value=https://yeonhl.github.io/en/>English</option></select></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>다크 모드</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">목차</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#개요>개요</a></li><li><a href=#핵심-요소>핵심 요소</a><ol><li><a href=#호스트>호스트</a></li><li><a href=#클라이언트>클라이언트</a></li><li><a href=#mcp-서버>MCP 서버</a></li><li><a href=#설계-원칙>설계 원칙</a></li></ol></li><li><a href=#데이터-모델>데이터 모델</a><ol><li><a href=#서버-프리미티브>서버 프리미티브</a><ol><li><a href=#도구-tools-행동과-상호작용-활성화-모델-제어>도구 (Tools): 행동과 상호작용 활성화 (모델 제어)</a></li><li><a href=#리소스-resources-수동적-지식-제공-애플리케이션-제어>리소스 (Resources): 수동적 지식 제공 (애플리케이션 제어)</a></li><li><a href=#프롬프트-prompts-사용자-주도-워크플로우-사용자-제어>프롬프트 (Prompts): 사용자 주도 워크플로우 (사용자 제어)</a></li></ol></li><li><a href=#클라이언트-프리미티브>클라이언트 프리미티브</a><ol><li><a href=#샘플링-sampling-서버의-언어-모델-추론-요청>샘플링 (Sampling): 서버의 언어 모델 추론 요청</a></li><li><a href=#정보-요청-elicitation-human-in-the-loop>정보 요청 (Elicitation): Human-in-the-loop</a></li><li><a href=#루트-roots-호스트-환경-상호작용>루트 (Roots): 호스트 환경 상호작용</a></li></ol></li><li><a href=#데이터-스키마와-검증-json-schema>데이터 스키마와 검증: JSON Schema</a></li></ol></li><li><a href=#통신>통신</a><ol><li><a href=#상태-에이전트-워크플로우-특화>상태: 에이전트 워크플로우 특화</a></li><li><a href=#세션-생명주기>세션 생명주기</a><ol><li><a href=#초기화-핸드셰이크-및-기능-협상>초기화: 핸드셰이크 및 기능 협상</a></li><li><a href=#운영-동적-컨텍스트-교환>운영: 동적 컨텍스트 교환</a></li><li><a href=#종료-정상적인-연결-해제>종료: 정상적인 연결 해제</a></li></ol></li><li><a href=#json-rpc-20>JSON-RPC 2.0</a></li><li><a href=#전송-방식>전송 방식</a><ol><li><a href=#stdio-표준-입출력><code>stdio</code> (표준 입출력)</a></li><li><a href=#streamable-http-레거시-httpsse-대체><code>Streamable HTTP</code> (레거시 <code>HTTP+SSE</code> 대체)</a></li></ol></li></ol></li><li><a href=#마치며>마치며</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/systems/>Systems</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/systems/mcp/architecture/>MCP 아키텍처</a></h2><h3 class=article-subtitle>MCP의 아키텍처 및 통신 과정을 이해하면서 내부 동작과 철학을 살펴보겠습니다.</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>8월 14, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>22 분 정도</time></div></footer></div></header><section class=article-content><h2 id=개요>개요</h2><p>이번 포스트에서는, MCP를 이루는 구성 요소들을 더 자세히 살펴보겠습니다. 각 요소가 어떤 목적으로 설계되었는지 알아보고 이에 맞게 아키텍처를 구성하는 것을 목표로 합니다.</p><h2 id=핵심-요소>핵심 요소</h2><p>이전 포스트에서 언급했듯이, Model Context Protocol (MCP)는 호스트(Host), 클라이언트(Client), 서버(Server)의 상호작용으로 동작합니다. 이 클라이언트-서버 아키텍처는 언어 서버 프로토콜(LSP)에서 영감을 받았으며, 각 구성요소의 역할을 분리함으로써 모듈성, 보안성 및 확장성을 달성합니다. 이 구성 요소들이 구체적으로 어떻게 동작하는지 알아보겠습니다.</p><blockquote><p><font color=#245bdb><b>NOTE: 언어 서버 프로토콜 (LSP)과의 비교</b></font></p><p>MCP는 코드 편집기와 언어별 도구 간의 통신을 표준화한 언어 서버 프로토콜(Language Server Protocol, LSP)에서 명시적으로 영감을 받았습니다. 그러나 MCP는 이 모델을 훨씬 더 확장합니다. LSP는 대체로 <strong>반응적(reactive)</strong> 입니다. 즉, IDE에서 사용자가 코드를 입력하거나 마우스를 올리는 등의 행동에 반응하여 진단 정보나 자동 완성을 제공합니다.</p><p>반면, MCP는 능동적인 <strong>에이전트 중심 실행 모델(agent-centric execution model)</strong> 을 지원하도록 설계되었습니다. 핵심적인 차이점은 <u>제어의 주체</u>입니다. LSP에서는 인간 사용자가 주된 에이전트입니다. MCP에서는 <strong>AI 모델</strong>이 에이전트입니다. MCP는 AI가 도구를 발견하고, 여러 도구를 연계하며(chaining), 다단계 계획을 실행하는 <span style=background:#fff88f>자율적</span> 워크플로우를 지원해야 함을 의미합니다. 이러한 능동성으로 MCP는 인간 주도 작업을 돕는 도우미를 넘어, 자율 에이전트의 중추적인 역할을 할 수 있습니다.</p></blockquote><h3 id=호스트>호스트</h3><p>MCP 호스트는 사용자가 직접 상호작용하는 <strong>AI 애플리케이션</strong>으로, VS Code와 같은 통합 개발 환경(IDE), Claude Desktop과 같은 데스크톱 어시스턴트, 또는 맞춤형 에이전트 애플리케이션의 형태를 가집니다. 호스트는 LLM을 포함하는 컨테이너 뿐만 아니라, <span style=background:#fff88f>모든 MCP 상호작용을 시작하고, 관리하며, 보호하는 복잡한 책임을 수행</span>합니다.</p><p>호스트의 핵심 책임은 다음과 같이 분류할 수 있습니다.</p><ul><li><p><strong>생명주기 관리 (Lifecycle Management):</strong> 호스트는 연결된 <u>각 MCP 서버에 대해 하나씩, 여러 MCP 클라이언트 인스턴스를 생성, 관리 및 종료할 책임</u>이 있습니다. 이는 전체 MCP 세션의 시작과 끝을 통제하는 역할입니다.</p></li><li><p><strong>오케스트레이션 (Orchestration):</strong> 호스트는 사용자 프롬프트나 에이전트 워크플로우에 대응하여 <u>어떤 서버의 기능이 필요한지를 결정</u>하는 주요 오케스트레이션 로직을 포함합니다. 예를 들어, 사용자가 &ldquo;오늘 가입한 고객 수는?&ldquo;이라고 질문하면, 호스트는 이 요청을 분석 MCP 서버로 라우팅하는 결정을 내립니다.</p></li><li><p><strong>컨텍스트 집계 (Context Aggregation):</strong> 호스트는 연결된 모든 클라이언트로부터 도구(Tools), 리소스(Resources), 프롬프트(Prompts)와 같은 <u>컨텍스트를 수집하고 병합하여 LLM에 제공</u>합니다. 여러 서버에서 제공하는 다양한 <u>컨텍스트를 하나의 일관된 프롬프트로 구성하는 이 복잡한 작업은 주로 호스트가 수행</u>하며, 프로토콜 자체는 이에 대한 구체적인 방법을 정의하지 않습니다.</p></li><li><p><strong>보안 및 동의 집행 (Security and Consent Enforcement):</strong> 호스트는 최종적인 보안 게이트키퍼 역할을 합니다. 사용자의 명시적인 동의 없이 도구를 실행하거나 데이터에 접근하는 것을 방지하고, 각 서버 간의 엄격한 보안 경계를 유지하며, 전반적인 보안 정책을 강제합니다. 이는 MCP 시스템의 신뢰성과 안전성을 보장하는 가장 중요한 기능입니다.</p></li></ul><h3 id=클라이언트>클라이언트</h3><p>MCP 클라이언트는 <u>독립적인 애플리케이션이 아닌, 호스트 프로세스 내에 존재</u>하는 <strong>저수준 컴포넌트</strong>입니다. 클라이언트의 핵심 역할은 <span style=background:#fff88f>단일 MCP 서버와의 연결을 관리</span>하는 중개자 역할입니다. 호스트가 <u>여러 서버와 통신해야 할 경우, 각 서버마다 별도의 클라이언트 인스턴스를 생성</u>하여 1:1 관계를 유지합니다.</p><p>클라이언트의 주요 책임은 다음과 같습니다.</p><ul><li><p><strong>1:1 연결 관리 (1:1 Connection Management):</strong> 각 클라이언트는 특정 MCP 서버와 단일의 <u>상태 저장(stateful) 세션을 설정하고 유지</u>합니다. 이 구조는 각 서버와의 통신을 격리하여 복잡성을 줄이고 보안을 강화합니다.</p></li><li><p><strong>프로토콜 변환 (Protocol Translation):</strong> 클라이언트는 <u>MCP 프로토콜의 기술적인 세부 사항을 처리</u>합니다. JSON-RPC 메시지를 양방향으로 라우팅하고, 초기 핸드셰이크 과정에서 기능 협상(capability negotiation)을 관리하며, 구독 및 알림과 같은 비동기 통신을 처리합니다.</p></li><li><p><strong>격리 유지 (Maintaining Isolation):</strong> 클라이언트는 호스트의 관점에서 <u>보안 경계를 강제</u>합니다. 한 클라이언트의 통신 채널이 다른 클라이언트의 채널을 &ldquo;엿보거나&rdquo; 간섭할 수 없도록 보장하여, 서버 간의 정보 유출을 원천적으로 차단합니다.</p></li></ul><h3 id=mcp-서버>MCP 서버</h3><p>MCP 서버는 <u>MCP 사양에 따라 특정하고 집중된 기능 집합을 노출</u>하는 <strong>독립적인 프로그램</strong>입니다. 서버는 로컬 머신에서 실행될 수도 있고(예: 파일 시스템 접근), 원격으로 호스팅될 수도 있습니다(예: Stripe API 연동). 서버의 핵심은 복잡한 <u>비즈니스 로직을 추상화</u>하고, 이를 <span style=background:#fff88f>LLM이 이해하고 사용할 수 있는 표준화된 형태로 제공</span>하는 것입니다.</p><p>서버의 핵심 책임은 다음과 같습니다.</p><ul><li><p><strong>프리미티브 노출 (Exposing Primitives):</strong> 서버는 표준화된 MCP 데이터 모델인 리소스, 도구, 프롬프트를 통해 클라이언트에 <span style=background:#fff88f>컨텍스트를 제공</span>합니다. 예를 들어, Git 서버는 <code>git_log</code>, <code>git_diff</code>와 같은 도구를 노출할 수 있습니다.</p></li><li><p><strong>집중된 로직 (Focused Logic):</strong> 서버는 단일 도메인이나 서비스에 집중하도록 설계되었습니다. 복잡한 오케스트레이션은 호스트의 역할이므로, 서버는 독립적으로 작동하며 <u>자신의 전문 분야에만 집중</u>합니다.</p></li><li><p><strong>제약 조건 준수 (Respecting Constraints):</strong> 서버는 호스트가 강제하는 보안 제약 및 권한 내에서 작동해야 합니다. 전체 대화 기록이나 다른 서버의 컨텍스트에 접근할 수 없으며, 호스트로부터 전달받은 최소한의 정보만을 사용하여 작업을 수행합니다.</p></li></ul><h3 id=설계-원칙>설계 원칙</h3><p>MCP의 아키텍처는 몇 가지 핵심적인 설계 원칙에 기반합니다. 이 원칙들은 프로토콜의 유연성과 견고성을 보장하는 기반이 됩니다.</p><ul><li><p><strong>결합성 (Composability):</strong> 각 서버는 독립적이고 모듈화된 단위입니다. 호스트는 여러 개의 <u>서버를 조합하여 복잡한 기능을 구성</u>할 수 있습니다. 예를 들어, 코드 분석 에이전트는 파일 시스템 서버, Git 서버, 정적 분석 서버를 동시에 사용하여 사용자 요청을 처리할 수 있습니다.</p></li><li><p><strong>격리 (Isolation):</strong> 서버 간의 엄격한 분리는 MCP의 근본적인 보안 원칙입니다. <span style=background:#fff88f>호스트가 유일한 컨텍스트 집계자 역할</span>을 함으로써, 서버는 인가되지 않은 데이터에 접근할 수 없으며 서버 간 상호 간섭으로 인한 위험이 완화됩니다.</p></li><li><p><strong>단순성 및 확장성 (Simplicity and Extensibility):</strong> 이 설계는 복잡한 <span style=background:#fff88f>오케스트레이션 로직을 호스트에 배치</span>하여 서버를 쉽게 구축할 수 있도록 만듭니다. 또한, 프로토콜은 기능 협상 메커니즘을 통해 점진적으로 확장 가능하도록 설계되었습니다.</p></li></ul><p>이러한 아키텍처는 의도적인 트레이드오프를 내포합니다. MCP 사양은 서버 개발 경험을 단순화하는 대신, <span style=background:#fff88f>복잡성과 책임을 호스트 구현에 집중</span>시킵니다. <u>서버는 간단하고, 격리되어 있으며, 특정 기능에 집중</u>합니다. 반면, <u>호스트는 모든 클라이언트를 관리하고, 모든 컨텍스트를 집계하며, 모든 보안 및 동의 정책을 시행</u>해야 합니다. 결과적으로, MCP 기반 시스템의 보안과 견고성은 프로토콜 자체보다는 <u>호스트 구현의 품질에 의해 결정</u>됩니다. 호스트는 신뢰, 통제, 그리고 잠재적 실패의 단일 지점(single point of trust and failure)이 됩니다. 핵심 과제는 단순히 서버에 연결하는 것이 아니라, <u>정교하고 안전한 호스트를 구축</u>하는 데 있습니다.</p><h2 id=데이터-모델>데이터 모델</h2><p>다음으로 살펴볼 것은 &ldquo;프리미티브(Primitives)&ldquo;입니다. 이전 포스트에서 데이터를 교환할 때 맥락을 보다 세분화된 표현으로 전달하기 위해 사용한다고 언급했습니다. 이는 프리미티브가 AI 애플리케이션과 공유할 수 있는 컨텍스트 정보의 유형과 수행할 수 있는 작업의 범위를 명시적으로 정의하기 때문입니다. 그렇다면 이들이 어떻게 풍부하고 구조화된 컨텍스트 교환을 가능하게 하는지 알아보겠습니다.</p><h3 id=서버-프리미티브>서버 프리미티브</h3><p>서버가 클라이언트에 컨텍스트를 제공하는 주요 방법은 세 가지 프리미티브를 통해 이루어집니다. 이를 누가 그것의 사용을 통제하는가에 대한 &lsquo;제어 모델&rsquo;에서 살펴보면 아키텍처를 알 수 있습니다.</p><h4 id=도구-tools-행동과-상호작용-활성화-모델-제어>도구 (Tools): 행동과 상호작용 활성화 (모델 제어)</h4><ul><li><p><strong>개념:</strong> 도구는 LLM이 발견하고 호출을 결정할 수 있는 실행 가능한 함수입니다. 데이터베이스 쿼리, API 호출, 파일 쓰기와 같이 <u>외부 시스템의 상태를 변경하거나 부작용(side effect)을 일으키는 작업을 수행</u>하는 데 사용됩니다. 예를 들어, OpenAI의 ChatGPT와 통합하기 위해서는 <code>search</code>와 <code>fetch</code>라는 특정 도구를 구현해야 합니다.</p></li><li><p><strong>제어 모델:</strong> &ldquo;모델 제어(Model-controlled)&ldquo;는 <span style=background:#fff88f>LLM이 사용자의 프롬프트와 도구의 설명을 바탕으로 자율적으로 특정 도구의 호출 여부와 시점을 결정</span>합니다.</p></li><li><p><strong>스키마:</strong> 도구 정의는 고유한 <code>name</code>, LLM의 의사결정에 결정적인 역할을 하는 <code>description</code>, 그리고 인수를 정의하는 <code>inputSchema</code>를 포함합니다. 결과 검증을 위한 <code>outputSchema</code>를 선택적으로 포함할 수도 있습니다. <code>inputSchema</code>는 일반적으로 JSON Schema 객체 형식입니다.</p></li></ul><h4 id=리소스-resources-수동적-지식-제공-애플리케이션-제어>리소스 (Resources): 수동적 지식 제공 (애플리케이션 제어)</h4><ul><li><p><strong>개념:</strong> 리소스는 LLM에 컨텍스트를 제공하는 읽기 전용의 파일과 유사한 데이터 객체입니다. 데이터베이스 스키마, 문서 내용, API 응답 등이 이에 해당하며, <u>부작용을 일으키지 않도록 설계</u>되었습니다.</p></li><li><p><strong>제어 모델:</strong> &ldquo;애플리케이션 제어(Application-controlled)&rdquo; 또는 &ldquo;사용자 제어(User-controlled)&ldquo;는 <span style=background:#fff88f>호스트 애플리케이션이나 사용자가</span> UI 요소(예: &lsquo;@&rsquo; 기호 입력, &lsquo;컨텍스트 추가&rsquo; 버튼 클릭)를 통해 명시적으로 리소스를 컨텍스트에 포함시킬 시점을 결정한다는 것을 의미합니다. <u>LLM은 자율적으로 리소스를 가져오도록 결정하지 않습니다.</u></p></li><li><p><strong>스키마:</strong> 리소스는 URI로 식별되며 <code>name</code>, <code>title</code>, <code>mimeType</code>과 같은 메타데이터를 포함합니다.</p></li></ul><h4 id=프롬프트-prompts-사용자-주도-워크플로우-사용자-제어>프롬프트 (Prompts): 사용자 주도 워크플로우 (사용자 제어)</h4><ul><li><p><strong>개념:</strong> 프롬프트는 <u>사용자 상호작용을 안내하거나 복잡한 작업을 구조화</u>하는, 미리 정의되고 매개변수화 가능한 메시지 템플릿입니다.</p></li><li><p><strong>제어 모델:</strong> &ldquo;사용자 제어(User-controlled)&ldquo;는 일반적으로 <span style=background:#fff88f>사용자가 UI 명령(예: 슬래시 명령어)을 통해 명시적으로 프롬프트를 선택</span>한다는 것을 의미합니다.</p></li><li><p><strong>스키마:</strong> 프롬프트 정의는 <code>name</code>, <code>description</code>, <code>arguments</code> 목록, 그리고 템플릿을 구성하는 <code>messages</code> 배열을 포함합니다.</p></li></ul><h3 id=클라이언트-프리미티브>클라이언트 프리미티브</h3><p>MCP는 서버가 클라이언트에게 특정 작업을 요청할 수 있는 프리미티브를 정의합니다. 이는 더욱 복잡하고 <u>양방향적인 워크플로우를 가능</u>하게 합니다.</p><h4 id=샘플링-sampling-서버의-언어-모델-추론-요청>샘플링 (Sampling): 서버의 언어 모델 추론 요청</h4><ul><li><p><strong>개념:</strong> 서버가 <span style=background:#fff88f>클라이언트의 LLM에게 추론 작업(예: 텍스트 생성, 콘텐츠 요약)을 수행하고 그 결과를 반환하도록 요청</span>할 수 있도록 허용합니다. 서버는 모델, 시스템 프롬프트, temperature와 같은 매개변수를 지정할 수 있습니다. 이는 AI 기능이 필요하지만 <u>특정 모델에 종속되지 않고 LLM SDK를 내장하고 싶지 않은 서버</u>에게 매우 중요합니다.</p></li><li><p><strong>사용 사례:</strong> Python SDK는 이를 위해 <code>ctx.session.create_message</code> 메서드를 제공합니다. 서버는 자체 API 키나 모델 종속성 없이, 샘플링을 사용하여 <u>자체 데이터를 처리하거나 요약한 후 결과를 반환</u>할 수 있습니다.</p></li></ul><h4 id=정보-요청-elicitation-human-in-the-loop>정보 요청 (Elicitation): Human-in-the-loop</h4><ul><li><p><strong>개념:</strong> 서버가 워크플로우를 일시 중지하고 호스트의 UI를 통해 <span style=background:#fff88f>사용자에게 추가 정보나 확인을 요청</span>할 수 있게 합니다. 서버는 필요한 입력에 대한 스키마를 정의합니다. 호스트가 이 상호작용을 중재하여 사용자 제어와 개인 정보 보호를 보장합니다. 이 기능은 에이전트가 중요한 결정 지점에서 사용자에게 명확한 설명이나 승인을 요청할 수 있는 <u>&ldquo;인간 참여형(human-in-the-loop)&rdquo; 워크플로우를 구현</u>하는 공식적인 메커니즘입니다.</p></li><li><p><strong>사용 사례:</strong> Python SDK 예제에서는 <code>book_table</code> 도구가 특정 날짜에 예약이 불가능할 경우 <code>ctx.elicit</code>을 사용하여 사용자에게 대체 날짜를 묻는 것을 보여줍니다. 다단계 인증이 필요한 도구는 정보 요청을 사용하여 서버가 직접 원시 입력을 처리하지 않고도 사용자에게 안전하게 코드를 입력하도록 요청할 수 있습니다.</p></li></ul><h4 id=루트-roots-호스트-환경-상호작용>루트 (Roots): 호스트 환경 상호작용</h4><ul><li><p><strong>개념</strong>: 서버가 허가를 받아 접근할 수 있는 <span style=background:#fff88f>호스트의 로컬 환경</span>에 대한 진입점입니다.</p></li><li><p><strong>사용 사례:</strong> 서버는 파일 시스템 디렉토리의 정보를 요청할 수 있습니다.</p></li></ul><h3 id=데이터-스키마와-검증-json-schema>데이터 스키마와 검증: JSON Schema</h3><ul><li><p><strong>스키마:</strong> MCP 사양은 TypeScript 스키마 파일(<code>schema.ts</code>)을 통해 정의됩니다. 이는 프로토콜의 <span style=background:#fff88f>모든 데이터 구조에 대한 단일 진실 공급원</span>(single source of truth) 역할을 합니다.</p></li><li><p><strong>구현:</strong> 실제 개발에서는 TypeScript의 Zod나 Python의 Pydantic과 같은 라이브러리를 사용하여 도구 인수 및 기타 프리미티브의 스키마를 정의하고 검증합니다. 이는 <u>타입 안정성을 보장하고 견고한 오류 처리</u>를 가능하게 합니다. 도구의 <code>inputSchema</code>는 일반적으로 JSON Schema 객체로 정의되어 언어에 구애받지 않는 상호 운용성을 제공합니다.</p></li></ul><p>프리미티브의 제어 모델 구분은 MCP에 내장된 근본적인 보안 및 사용자 경험(UX) 설계 패턴입니다. 이는 개발자가 AI 에이전트가 특정 기능에 대해 가져야 할 자율성의 수준을 추론할 수 있는 프레임워크를 제공하여, 시스템이 얼마나 안전하고 예측 가능하게 작동할지에 직접적인 영향을 미칩니다. 예를 들어, <u>민감한 작업은 LLM이 예기치 않게 호출할 수 있는 &lsquo;도구&rsquo;보다는 명시적인 사용자 조치가 필요한 &lsquo;리소스&rsquo;로 노출</u>해야 합니다. 이처럼 제어 모델을 올바르게 선택하는 것은 안전하고 신뢰할 수 있는 AI 에이전트를 설계하는 데 있어 가장 중요한 아키텍처 결정 중 하나입니다.</p><h2 id=통신>통신</h2><p>앞에서 데이터 모델(&ldquo;무엇을&rdquo;)을 알아봤다면, 이제는 통신 메커니즘(&ldquo;어떻게&rdquo;)으로 초점을 전환합니다. MCP의 기본 프로토콜 및 전송 계층, 상태 저장 세션 생명주기까지 전체 통신 시퀀스를 살펴보겠습니다.</p><h3 id=상태-에이전트-워크플로우-특화>상태: 에이전트 워크플로우 특화</h3><p>RESTful API는 상태 비저장(stateless) 방식으로 작동합니다. 각 요청은 이전 요청과 독립적으로 처리되며, 클라이언트는 여러 단계에 걸친 <u>작업의 상태와 컨텍스트를 스스로 관리해야 할 책임</u>이 있습니다.</p><p>이는 간단한 데이터 조회에는 효율적일 수 있으나, 여러 단계의 <u>상호작용이 필요한 복잡한 작업을 수행하는 AI 에이전트에게는 상당한 부담</u>입니다. 에이전트 또는 클라이언트 측 오케스트레이터가 모든 상태를 기억하고 매 요청마다 전체 컨텍스트를 다시 전송하는 유일한 상태 관리자가 되면서 비효율적이고 시스템을 취약하게 만드는 원인이 됩니다.</p><p>반면, MCP는 <strong>상태를 유지하는(stateful) 영속적인 연결(persistent connections)</strong> 을 기반으로 설계되었습니다. 이는 일련의 개별적인 요청-응답이 아닌, 마치 웹소켓(WebSocket) 세션과 유사한 지속적인 양방향 통신 채널을 구축하는 것을 의미합니다.</p><p>상태 유지 연결은 다단계 작업 수행에 있어 결정적인 장점을 가집니다. 서버는 진행 중인 워크플로우의 컨텍스트를 세션 내에서 유지할 수 있으므로, 클라이언트는 <u>매번 전체 컨텍스트를 다시 보낼 필요가 없습니다.</u> 인지적 부담의 일부를 도구 서버로 오프로드합니다. 이를 통해 <span style=background:#fff88f>도구 자체가 메모리를 가지고 에이전트를 특정 프로세스로 안내하는 등 훨씬 더 정교한 상호작용이 가능</span>해집니다.</p><blockquote><p>MCP 로드맵에서도 <u>연결 끊김 및 재연결에 대한 탄력적인 처리와 장기 실행 작업을 지원하는 것이 핵심 우선순위</u>로 명시되어 있으며, 이는 상태 유지가 핵심 설계임을 의미합니다.</p></blockquote><p>이러한 아키텍처적 선택은 기술적 편의를 넘어, 에이전트와 도구 간의 상호작용 모델을 단순한 &lsquo;요청-응답&rsquo;에서 <strong>&lsquo;대화형 상호작용&rsquo; 모델</strong>로 전환시킵니다. 그리고 AI 에이전트와 도구 간의 관계를 &lsquo;파트너십&rsquo;으로 발전시키는 &ldquo;협력적 인지(collaborative cognition)&ldquo;라는 새로운 패러다임을 가능하게 합니다. 도구는 <u>더 이상 수동적으로 호출되는 함수가 아니라, 문제 해결 과정에 능동적으로 참여하는 주체</u>가 됩니다. 이는 고급 에이전트 행동을 위한 필수 전제 조건입니다.</p><p>구체적으로 살펴보겠습니다. 상태 비저장 API는 거래적(transactional)입니다. 에이전트가 도구에게 명령하면, 과거 상호작용에 대한 기억이 없는 도구는 그저 명령을 수행합니다. 그러나 MCP의 상태 유지 연결은 서버가 세션의 컨텍스트를 &ldquo;기억"할 수 있음을 의미합니다. 예를 들어, &ldquo;순차적 사고(Sequential Thinking)&rdquo; 서버는 동적인 문제 해결 과정을 추적할 수 있습니다.</p><p>여기에 <code>Elicitation</code> 및 <code>Sampling</code>과 같은 서버 주도 상호작용 기능은 <u>서버가 통신을 시작하여 에이전트에게 추가 정보를 요청하거나 추론 작업을 수행하도록 요청</u>할 수 있게 합니다. 이는 강력한 피드백 루프를 형성합니다. 에이전트가 도구에 도움을 요청하면, 도구는 자체 상태와 전문화된 로직을 사용하여 추가 정보가 필요하다고 판단하고 에이전트에게 다시 질문(<code>Elicitation</code>)하거나, 창의적인 단계가 필요하다고 판단하여 에이전트에게 텍스트 생성을 요청(<code>Sampling</code>)할 수 있습니다. 결과적으로 복잡한 문제를 해결하는 데 필요한 인지적 부하가 분산됩니다.</p><p>정리하면, LLM은 일반적인 추론과 언어를 처리하고, 전문화된 MCP 서버는 <span style=background:#fff88f>도메인 특화 로직, 상태 및 상호작용 흐름을 처리</span>합니다. 이 협력 모델은 LLM이 모든 것을 관리해야 하는 모델보다 훨씬 더 강력하고 효율적입니다.</p><h3 id=세션-생명주기>세션 생명주기</h3><p>생명주기의 핵심은 &lsquo;기능 협상&rsquo; 과정으로, 클라이언트와 서버가 서로가 제공하고 지원하는 기능을 동적으로 확인하고 합의하는 절차입니다.</p><h4 id=초기화-핸드셰이크-및-기능-협상>초기화: 핸드셰이크 및 기능 협상</h4><ol><li><p><strong>초기화 (<code>initialize</code>):</strong> 연결이 시작되면, 클라이언트는 먼저 <code>initialize</code> 요청을 서버에 보냅니다. 이 요청에는 <u>클라이언트가 지원하는 프로토콜 버전 정보와 함께, 클라이언트가 제공할 수 있는 기능</u>(예: 서버로부터 LLM 추론 요청을 받을 수 있는 <code>sampling</code> 기능 지원 여부)<u>에 대한 정보가 포함</u>됩니다.</p></li><li><p><strong>기능 협상 (Response to <code>initialize</code>):</strong> <code>initialize</code> 요청을 받은 서버는 <u>자신의 정보(이름, 버전 등)와 함께 자신이 제공할 수 있는 기능의 목록을 담아 응답</u>합니다. 예를 들어, 서버는 자신이 <code>tools</code>와 <code>resources</code> 프리미티브를 제공하는지, 그리고 도구 목록이 변경될 때 <code>listChanged</code> 알림을 보낼 수 있는지 여부를 <code>capabilities</code> 객체에 담아 클라이언트에 알립니다. 이 교환 과정을 통해 양측은 세션에서 <span style=background:#fff88f>어떤 종류의 상호작용이 가능한지에 대해 명시적으로 합의</span>하게 됩니다.</p></li><li><p><strong>초기화 완료 (<code>initialized</code>):</strong> 서버로부터 기능 목록을 성공적으로 수신한 클라이언트는 <code>initialized</code><u> 알림을 서버에 보내 핸드셰이크가 완료되었음을 알립니다. </u>이 시점부터 본격적인 상호작용이 시작됩니다.</p></li></ol><h4 id=운영-동적-컨텍스트-교환>운영: 동적 컨텍스트 교환</h4><p>이 단계에서는 클라이언트와 서버가 초기화 단계에서 협상된 기능에 따라 요청, 응답, 알림을 자유롭게 교환합니다. 예를 들어, 클라이언트는 <code>tools/list</code>로 사용 가능한 도구를 확인하고 <code>tools/call</code>로 특정 도구를 실행할 수 있으며, 서버는 <code>notifications/prompts/list_changed</code> 알림을 보내 프롬프트 목록의 변경 사항을 알릴 수 있습니다.</p><h4 id=종료-정상적인-연결-해제>종료: 정상적인 연결 해제</h4><p>연결은 기본 전송 메커니즘을 사용하여 정상적으로 종료됩니다. <code>stdio</code>의 경우 <code>stdin</code> 스트림을 닫고, HTTP 세션의 경우 <code>DELETE</code> 요청을 보내는 방식입니다.</p><blockquote><p><font color=#245bdb><b>NOTE: 상태 저장 세션과 기능 협상 채택의 목적</b></font></p><p>초기 핸드셰이크는 단순한 인증 절차가 아니라, 세션의 &ldquo;계약 조건"을 설정하는 공식적인 협상 과정입니다. 이 상태 저장 및 협상된 컨텍스트는 <code>listChanged</code>와 같은 동적 업데이트 알림, <code>sampling</code>과 같은 서버 주도 요청, 세션 내 효율적인 컨텍스트 캐싱 등 상태 비저장 모델에서는 불가능한 <u>고급 기능을 가능</u>하게 합니다.</p><p>이는 클라이언트와 서버가 독립적으로 개발되고 시간이 지남에 따라 새로운 기능을 추가할 수 있게 하면서도, 핸드셰이크를 통해 <u>하위 호환성을 보장하고 지원되지 않는 작업으로 인한 런타임 오류를 방지</u>합니다. 이것이 프로토콜의 확장성과 장기적인 생존 가능성의 핵심입니다.</p></blockquote><h3 id=json-rpc-20>JSON-RPC 2.0</h3><p>MCP는 메시징 형식을 위해 널리 확립된 <strong>JSON-RPC 2.0</strong> 프로토콜을 기반으로 구축되었습니다.3 이는 요청, 응답 및 오류 처리를 위한 표준화된 구조를 제공하여 프로토콜의 안정성과 예측 가능성을 높입니다.</p><ul><li><p><strong>요청(Request):</strong> 요청 메시지는 클라이언트가 서버의 특정 기능을 호출하기 위해 전송하는 통신의 시작점입니다. 이 메시지는 <code>jsonrpc</code>, <code>method</code>, <code>params</code>, 그리고 고유한 <code>id</code> 필드를 포함합니다. <code>method</code> 필드는 <code>tools/call</code>이나 <code>resources/list</code>와 같이 호출할 함수의 이름을 명시합니다. 가장 중요한 것은 <code>id</code> 필드로, 모든 요청을 고유하게 식별하여 비동기적인 환경에서도 요청과 응답을 정확하게 연결하는 역할을 합니다. <code>id</code>의 존재는 MCP가 단순한 단방향 호출이 아닌, <span style=background:#fff88f>상태를 추적하고 관리하는 상태 기반(stateful) 상호작용을 전제로 설계</span>되었음을 보여줍니다.</p></li><li><p><strong>응답(Response):</strong> 서버는 요청을 처리한 후, 반드시 해당 요청의 <code>id</code><span style=background:#fff88f>를 포함하는 응답 메시지를 반환</span>합니다. 작업이 성공했을 경우 <code>result</code> 필드에 결과 데이터를 보내고, 실패했을 경우에는 <code>error</code> 필드에 에러 코드와 메시지를 보냅니다.</p></li><li><p><strong>알림(Notification):</strong> 알림은 요청과 달리 <code>id</code> 필드가 없어 <span style=background:#fff88f>응답을 요구하지 않는 단방향 메시지</span>입니다. 이는 서버가 <u>자신의 상태 변화를 클라이언트에게 능동적으로 전파</u>해야 할 때 사용합니다. 예를 들어, 서버에 새로운 도구가 추가되거나 기존 도구가 제거되었을 때, 서버는 <code>notifications/tools/list_changed</code> 알림을 보내 클라이언트가 최신 도구 목록을 유지할 수 있도록 합니다. 이 메커니즘은 MCP 환경을 정적인 상태가 아닌, <u>동적으로 변화하고 반응하는 생태계로 만드는 핵심 요소</u>로 작용합니다.</p></li></ul><blockquote><p><font color=#245bdb><b>TIP: 도구 변동 알림이 필요한 이유</b></font></p><p>성능 향상을 위해 호스트는 <span style=background:#fff88f>서버로부터 받은 도구 목록을 캐시</span>합니다. 이 캐시가 오래된 정보가 되는 것을 방지하기 위해, 서버는 초기화 시 <code>listChanged: true</code> 기능을 선언할 수 있습니다.</p><p>만약 서버에서 사용 가능한 도구가 변경되면, 서버는 <code>notifications/tools/list_changed</code> <u>알림을 보냅니다.</u> 이 알림을 받은 호스트는 자신의 캐시가 오래되었음을 인지하고 <code>tools/list</code>를 다시 요청하여 도구 목록을 갱신합니다.</p><p>이 이벤트 기반 모델은 <u>지속적으로 서버 상태를 확인하는 폴링(polling) 방식보다 훨씬 효율적</u>입니다.</p></blockquote><h3 id=전송-방식>전송 방식</h3><p>MCP는 배포 시나리오와 요구사항에 맞게 전송 방식을 정할 수 있습니다. MCP 프로토콜 자체는 특정 전송 방식에 종속되지 않지만, 두 가지 표준 메커니즘을 정의하여 대부분의 사용 사례를 지원합니다.</p><p>이러한 이중화된 전송 메커니즘은 MCP가 &lsquo;보안&rsquo;을 중시하는 로컬 환경과 &lsquo;확장성&rsquo;을 중시하는 원격 클라우드 환경이라는 두 가지 핵심 가치를 동시에 추구하기 위한 의도적인 설계적 타협입니다. 개발자는 자신의 사용 사례에 맞춰 최적의 전송 방식을 선택할 수 있지만, 이는 동시에 MCP 클라이언트(호스트)가 두 가지 상이한 통신 모델을 모두 안정적으로 처리해야 하는 기술적 과제를 가집니다.</p><h4 id=stdio-표준-입출력><code>stdio</code> (표준 입출력)</h4><ul><li><p><strong>메커니즘:</strong> 이 방식은 MCP <span style=background:#fff88f>서버가 호스트 애플리케이션(예: IDE, 데스크톱 앱)의 로컬 서브프로세스로 실행될 때</span> 사용됩니다. 통신은 운영체제의 표준 입력(stdin)과 표준 출력(stdout) 스트림을 통해 이루어집니다. 가장 큰 장점은 네트워크 스택을 거치지 않아 <u>지연 시간이 마이크로초 단위로 극도로 낮고</u>, 운영체제 수준의 프로세스 격리를 통해 외부 네트워크로부터의 접근이 원천적으로 차단되어 <u>보안성이 매우 높다</u>는 점입니다.</p></li><li><p><strong>사용 사례:</strong> VS Code나 Claude Desktop과 같은 개발 도구에서 사용자의 로컬 파일 시스템에 접근하거나 로컬 스크립트를 실행하는 등 민감한 작업을 안전하고 신속하게 처리하는 데 최적화되어 있습니다. <span style=background:#fff88f>단일 사용자, 로컬 전용 시나리오</span>에 대해 간단하고 안전한 통신을 제공합니다.</p></li></ul><h4 id=streamable-http-레거시-httpsse-대체><code>Streamable HTTP</code> (레거시 <code>HTTP+SSE</code> 대체)</h4><ul><li><p><strong>메커니즘:</strong> 원격 또는 네트워크 서버에 사용됩니다. 단일 표준 HTTP 연결을 통해 더 확장 가능하고 효율적인 양방향 통신을 가능하게 합니다. 주로 청크 분할 전송 인코딩(chunked transfer encoding)을 사용합니다.</p></li><li><p><strong>사용 사례:</strong> 클라우드 배포(예: AWS Lambda) 및 엄격한 방화벽 규칙이 있는 엔터프라이즈 네트워크 환경에 적합합니다. 웹 서비스, 서드파티 API 또는 다중 사용자/원격 서비스 연결에 필수적입니다. <code>Mcp-Session-Id</code> 헤더를 통해 <span style=background:#fff88f>상태 저장 세션을 지원</span>하여, 여러 요청에 걸쳐 컨텍스트를 유지할 수 있습니다.</p></li></ul><blockquote><p>전송 계층이 STDIO/SSE에서 Streamable HTTP로 발전한 것은 MCP가 개발자 중심의 로컬 우선 도구에서 엔터프라이즈급 클라우드 네이티브 프레임워크로 전략적으로 전환하고 있음을 보여줍니다. Streamable HTTP는 단방향 통신이라는 SSE의 한계와 웹소켓의 운영 복잡성을 극복하고, <u>원격 보안 통신을 위한 강력하고 널리 호환되는 솔루션</u>을 제공합니다.</p></blockquote><blockquote><p><font color=#245bdb><b>NOTE: <code>HTTP+SSE</code> 방식이 대체된 이유</b></font></p><p><code>Streamable HTTP</code> 이전 <u>원격 서버와의 통신</u>을 위해 설계되었습니다. 클라이언트에서 서버로의 요청은 일반적인 HTTP POST 요청을 사용하고, 서버에서 클라이언트로의 지속적인 데이터 스트리밍은 Server-Sent Events(SSE)를 통해 이루어집니다.</p><p>SSE는 <span style=background:#fff88f>단방향(서버→클라이언트) 통신</span> 채널을 오랫동안 유지하며 업데이트를 푸시하는 데 특화되어 있습니다. 이 방식은 기존 웹 인프라(프록시, 방화벽, 로드밸런서)와 완벽하게 호환되므로, Stripe, GitHub, Sentry 등 클라우드 기반의 원격 SaaS API를 MCP 서버로 연동하는 데 이상적입니다.</p><p>다만, 양방향 통신을 위해 <u>요청(HTTP POST)과 응답 스트림(SSE)을 별도의 채널로 관리해야 하는 복잡성이 존재</u>했고, 최신 MCP 사양에서는 이러한 복잡성을 줄이기 위해 단일 HTTP 연결 내에서 양방향 스트리밍을 지원하는 <code>Streamable HTTP</code><u>로의 통합을 추진</u>하고 있습니다.</p></blockquote><blockquote><p><font color=#245bdb><b>NOTE: <code>WebSockets</code></b></font></p><p>최대의 상호작용성이 요구될 경우 사용 가능한 전송 방식입니다. 완전한 양방향(full-duplex) 통신을 제공하여 스트리밍 데이터, 진행 상황 업데이트, 협업 상호작용 등이 포함된 복잡한 AI 워크플로우에 특히 유용할 수 있습니다.</p></blockquote><div class=table-wrapper><table><thead><tr><th>특성</th><th><code>stdio</code> (Standard Input/Output)</th><th><code>HTTP+SSE</code></th><th><code>Streamable HTTP</code></th><th><code>WebSockets</code> (대안)</th></tr></thead><tbody><tr><td><strong>통신 모델</strong></td><td>양방향</td><td>단방향 (서버→클라이언트)</td><td>양방향 (단일 연결)</td><td>완전 양방향 (Full-duplex)</td></tr><tr><td><strong>주요 장점</strong></td><td>- 매우 낮은 지연 시간 - 네트워크 설정 불필요 - OS 수준의 높은 보안 (샌드박싱)</td><td>- 기존 웹 인프라와 호환 - 실시간 결과 스트리밍 가능</td><td>- 기존 웹 인프라와 호환 - 서버리스 환경 지원 - 실시간 결과 스트리밍 가능</td><td>- 진정한 실시간 양방향 통신 - 단일 연결 관리로 인한 단순성</td></tr><tr><td><strong>주요 단점/고려사항</strong></td><td>- 원격 서버 연결 불가 - 호스트가 서버 프로세스 생명주기 관리 필요</td><td>- 양방향 통신을 위한 채널 관리 복잡성 (HTTP+SSE) - 장기 연결을 위한 프록시/로드밸런서 설정 필요</td><td>- 장기 연결을 위한 프록시/로드밸런서 설정 필요</td><td>- 일부 기업 네트워크에서 제한될 수 있음 - 초기 핸드셰이크 오버헤드 존재</td></tr><tr><td><strong>대표 사용 사례</strong></td><td>- IDE 플러그인 (VS Code, Cursor) - 로컬 파일 시스템 접근 - 데스크톱 AI 어시스턴트 (Claude Desktop)</td><td>원격 API 연동 (Stripe, Sentry) - 클라우드 기반 데이터 소스 연결 - 웹 브라우저 기반 클라이언트</td><td>- 원격 API 연동 (Stripe, Sentry) - 클라우드 기반 데이터 소스 연결 - 웹 브라우저 기반 클라이언트</td><td>- 고빈도 상호작용이 필요한 채팅 애플리케이션 - 실시간 협업 도구</td></tr><tr><td><strong>지연 시간</strong></td><td>매우 낮음</td><td>낮음-중간</td><td>낮음-중간</td><td>매우 낮음</td></tr><tr><td><strong>확장성</strong></td><td>제한적 (단일 머신)</td><td>중간</td><td>높음</td><td>높음</td></tr><tr><td><strong>네트워크 호환성</strong></td><td>해당 없음 (로컬)</td><td>표준 HTTP/S 포트</td><td>표준 HTTP/S 포트</td><td>별도 프로토콜/포트 필요 가능</td></tr><tr><td><strong>현재 상태</strong></td><td>활성</td><td>사용되지 않음 (Deprecated)</td><td><strong>현재 표준</strong></td><td>고려 대상</td></tr></tbody></table></div><hr><h2 id=마치며>마치며</h2><p>이번 포스트에서는 MCP 생태계를 이루는 각 요소와 그 역할, 데이터 교환을 위한 각 프리미티브의 목적, MCP 통신의 특징과 그 목적을 확인했습니다. MCP 설계 과정에 담긴 철학을 확인하고 이에 맞게 아키텍처를 설계했을 때 향후 업데이트 및 생태계의 지원을 기대할 수 있다고 생각합니다.</p><p>포스트를 위한 자료를 찾아보면서, 내부 동작이 어떻게 이루어지는지 자세히 이해할 수 있었습니다. 또한 MCP가 상태를 저장하는 목적을 명확하게 알 수 있었습니다. 여러 에이전트가 공통으로 사용할 수 있는 기능들을 어떻게 재사용할 것인지 고민이 있었는데, MCP에 담긴 도메인 로직 구현의 철학에서 그에 대한 답변을 얻은 것 같습니다.</p><p>다음 포스트에서는 MCP를 비즈니스 환경에서 설계하고 구현할 때, 보안 등의 측면에서 고려해야 할 점에 대해 살펴보겠습니다. 이후에는 MCP의 아키텍처와 철학, 고려할 점을 반영하여 개발하는 과정을 작성하려 합니다.</p><blockquote><p>본 포스트는 Google Gemini의 응답을 기반으로 저의 의견을 반영하여 다시 작성했습니다.</p></blockquote></section><footer class=article-footer><section class=article-tags><a href=/tags/mcp/>MCP</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>마지막 수정: 9월 16, 2025 00:00 UTC</span></section></footer></article><div class=back-to-list style=margin-top:2rem;text-align:center><a href=/systems/mcp/>← MCP (Model Context Protocol) 목록으로 돌아가기</a></div><nav class=post-navigation style="display:flex;justify-content:space-between;margin-top:2rem;border-top:1px solid #eee;padding-top:1rem"><div><a class=prev-post href=https://yeonhl.github.io/systems/mcp/concept/><span style=font-size:.9em;color:#666>&larr; 이전 글</span><br><strong style=font-size:1.1em>MCP의 개념</strong></a></div><div style=text-align:right></div></nav><aside class=related-content--wrapper><h2 class=section-title>관련 글</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/systems/mcp/concept/><div class=article-details><h2 class=article-title>MCP의 개념</h2></div></a></article><article><a href=/systems/model_serving/monitoring/><div class=article-details><h2 class=article-title>모델 서빙의 모니터링</h2></div></a></article><article><a href=/systems/model_serving/concept/><div class=article-details><h2 class=article-title>모델 서빙의 개념</h2></div></a></article><article><a href=/systems/agents/concept/><div class=article-details><h2 class=article-title>에이전트의 개념</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//https-yeonhl-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2025 연호의 블로그</section><section class=powerby><a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a>로 만듦<br><a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>의 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.31.0>Stack</a></b> 테마 사용 중</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>