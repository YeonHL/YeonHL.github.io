<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MCP on 연호의 블로그</title><link>https://yeonhl.github.io/tags/mcp/</link><description>Recent content in MCP on 연호의 블로그</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Tue, 16 Sep 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://yeonhl.github.io/tags/mcp/index.xml" rel="self" type="application/rss+xml"/><item><title>MCP 아키텍처</title><link>https://yeonhl.github.io/systems/mcp/architecture/</link><pubDate>Thu, 14 Aug 2025 19:03:00 +0000</pubDate><guid>https://yeonhl.github.io/systems/mcp/architecture/</guid><description>&lt;h2 id="개요"&gt;개요
&lt;/h2&gt;&lt;p&gt;이번 포스트에서는, MCP를 이루는 구성 요소들을 더 자세히 살펴보겠습니다. 각 요소가 어떤 목적으로 설계되었는지 알아보고 이에 맞게 아키텍처를 구성하는 것을 목표로 합니다.&lt;/p&gt;
&lt;h2 id="핵심-요소"&gt;핵심 요소
&lt;/h2&gt;&lt;p&gt;이전 포스트에서 언급했듯이, Model Context Protocol (MCP)는 호스트(Host), 클라이언트(Client), 서버(Server)의 상호작용으로 동작합니다. 이 클라이언트-서버 아키텍처는 언어 서버 프로토콜(LSP)에서 영감을 받았으며, 각 구성요소의 역할을 분리함으로써 모듈성, 보안성 및 확장성을 달성합니다. 이 구성 요소들이 구체적으로 어떻게 동작하는지 알아보겠습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font color="#245bdb"&gt;&lt;b&gt;NOTE: 언어 서버 프로토콜 (LSP)과의 비교&lt;/b&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;MCP는 코드 편집기와 언어별 도구 간의 통신을 표준화한 언어 서버 프로토콜(Language Server Protocol, LSP)에서 명시적으로 영감을 받았습니다. 그러나 MCP는 이 모델을 훨씬 더 확장합니다. LSP는 대체로 &lt;strong&gt;반응적(reactive)&lt;/strong&gt; 입니다. 즉, IDE에서 사용자가 코드를 입력하거나 마우스를 올리는 등의 행동에 반응하여 진단 정보나 자동 완성을 제공합니다.&lt;/p&gt;
&lt;p&gt;반면, MCP는 능동적인 &lt;strong&gt;에이전트 중심 실행 모델(agent-centric execution model)&lt;/strong&gt; 을 지원하도록 설계되었습니다. 핵심적인 차이점은 &lt;u&gt;제어의 주체&lt;/u&gt;입니다. LSP에서는 인간 사용자가 주된 에이전트입니다. MCP에서는 &lt;strong&gt;AI 모델&lt;/strong&gt;이 에이전트입니다. MCP는 AI가 도구를 발견하고, 여러 도구를 연계하며(chaining), 다단계 계획을 실행하는 &lt;span style="background:#fff88f"&gt;자율적&lt;/span&gt; 워크플로우를 지원해야 함을 의미합니다. 이러한 능동성으로 MCP는 인간 주도 작업을 돕는 도우미를 넘어, 자율 에이전트의 중추적인 역할을 할 수 있습니다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id="호스트"&gt;호스트
&lt;/h3&gt;&lt;p&gt;MCP 호스트는 사용자가 직접 상호작용하는 &lt;strong&gt;AI 애플리케이션&lt;/strong&gt;으로, VS Code와 같은 통합 개발 환경(IDE), Claude Desktop과 같은 데스크톱 어시스턴트, 또는 맞춤형 에이전트 애플리케이션의 형태를 가집니다. 호스트는 LLM을 포함하는 컨테이너 뿐만 아니라, &lt;span style="background:#fff88f"&gt;모든 MCP 상호작용을 시작하고, 관리하며, 보호하는 복잡한 책임을 수행&lt;/span&gt;합니다.&lt;/p&gt;
&lt;p&gt;호스트의 핵심 책임은 다음과 같이 분류할 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;생명주기 관리 (Lifecycle Management):&lt;/strong&gt; 호스트는 연결된 &lt;u&gt;각 MCP 서버에 대해 하나씩, 여러 MCP 클라이언트 인스턴스를 생성, 관리 및 종료할 책임&lt;/u&gt;이 있습니다. 이는 전체 MCP 세션의 시작과 끝을 통제하는 역할입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;오케스트레이션 (Orchestration):&lt;/strong&gt; 호스트는 사용자 프롬프트나 에이전트 워크플로우에 대응하여 &lt;u&gt;어떤 서버의 기능이 필요한지를 결정&lt;/u&gt;하는 주요 오케스트레이션 로직을 포함합니다. 예를 들어, 사용자가 &amp;ldquo;오늘 가입한 고객 수는?&amp;ldquo;이라고 질문하면, 호스트는 이 요청을 분석 MCP 서버로 라우팅하는 결정을 내립니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;컨텍스트 집계 (Context Aggregation):&lt;/strong&gt; 호스트는 연결된 모든 클라이언트로부터 도구(Tools), 리소스(Resources), 프롬프트(Prompts)와 같은 &lt;u&gt;컨텍스트를 수집하고 병합하여 LLM에 제공&lt;/u&gt;합니다. 여러 서버에서 제공하는 다양한 &lt;u&gt;컨텍스트를 하나의 일관된 프롬프트로 구성하는 이 복잡한 작업은 주로 호스트가 수행&lt;/u&gt;하며, 프로토콜 자체는 이에 대한 구체적인 방법을 정의하지 않습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;보안 및 동의 집행 (Security and Consent Enforcement):&lt;/strong&gt; 호스트는 최종적인 보안 게이트키퍼 역할을 합니다. 사용자의 명시적인 동의 없이 도구를 실행하거나 데이터에 접근하는 것을 방지하고, 각 서버 간의 엄격한 보안 경계를 유지하며, 전반적인 보안 정책을 강제합니다. 이는 MCP 시스템의 신뢰성과 안전성을 보장하는 가장 중요한 기능입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="클라이언트"&gt;클라이언트
&lt;/h3&gt;&lt;p&gt;MCP 클라이언트는 &lt;u&gt;독립적인 애플리케이션이 아닌, 호스트 프로세스 내에 존재&lt;/u&gt;하는 &lt;strong&gt;저수준 컴포넌트&lt;/strong&gt;입니다. 클라이언트의 핵심 역할은 &lt;span style="background:#fff88f"&gt;단일 MCP 서버와의 연결을 관리&lt;/span&gt;하는 중개자 역할입니다. 호스트가 &lt;u&gt;여러 서버와 통신해야 할 경우, 각 서버마다 별도의 클라이언트 인스턴스를 생성&lt;/u&gt;하여 1:1 관계를 유지합니다.&lt;/p&gt;
&lt;p&gt;클라이언트의 주요 책임은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;1:1 연결 관리 (1:1 Connection Management):&lt;/strong&gt; 각 클라이언트는 특정 MCP 서버와 단일의 &lt;u&gt;상태 저장(stateful) 세션을 설정하고 유지&lt;/u&gt;합니다. 이 구조는 각 서버와의 통신을 격리하여 복잡성을 줄이고 보안을 강화합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;프로토콜 변환 (Protocol Translation):&lt;/strong&gt; 클라이언트는 &lt;u&gt;MCP 프로토콜의 기술적인 세부 사항을 처리&lt;/u&gt;합니다. JSON-RPC 메시지를 양방향으로 라우팅하고, 초기 핸드셰이크 과정에서 기능 협상(capability negotiation)을 관리하며, 구독 및 알림과 같은 비동기 통신을 처리합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;격리 유지 (Maintaining Isolation):&lt;/strong&gt; 클라이언트는 호스트의 관점에서 &lt;u&gt;보안 경계를 강제&lt;/u&gt;합니다. 한 클라이언트의 통신 채널이 다른 클라이언트의 채널을 &amp;ldquo;엿보거나&amp;rdquo; 간섭할 수 없도록 보장하여, 서버 간의 정보 유출을 원천적으로 차단합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="mcp-서버"&gt;MCP 서버
&lt;/h3&gt;&lt;p&gt;MCP 서버는 &lt;u&gt;MCP 사양에 따라 특정하고 집중된 기능 집합을 노출&lt;/u&gt;하는 &lt;strong&gt;독립적인 프로그램&lt;/strong&gt;입니다. 서버는 로컬 머신에서 실행될 수도 있고(예: 파일 시스템 접근), 원격으로 호스팅될 수도 있습니다(예: Stripe API 연동). 서버의 핵심은 복잡한 &lt;u&gt;비즈니스 로직을 추상화&lt;/u&gt;하고, 이를 &lt;span style="background:#fff88f"&gt;LLM이 이해하고 사용할 수 있는 표준화된 형태로 제공&lt;/span&gt;하는 것입니다.&lt;/p&gt;
&lt;p&gt;서버의 핵심 책임은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;프리미티브 노출 (Exposing Primitives):&lt;/strong&gt; 서버는 표준화된 MCP 데이터 모델인 리소스, 도구, 프롬프트를 통해 클라이언트에 &lt;span style="background:#fff88f"&gt;컨텍스트를 제공&lt;/span&gt;합니다. 예를 들어, Git 서버는 &lt;code&gt;git_log&lt;/code&gt;, &lt;code&gt;git_diff&lt;/code&gt;와 같은 도구를 노출할 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;집중된 로직 (Focused Logic):&lt;/strong&gt; 서버는 단일 도메인이나 서비스에 집중하도록 설계되었습니다. 복잡한 오케스트레이션은 호스트의 역할이므로, 서버는 독립적으로 작동하며 &lt;u&gt;자신의 전문 분야에만 집중&lt;/u&gt;합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;제약 조건 준수 (Respecting Constraints):&lt;/strong&gt; 서버는 호스트가 강제하는 보안 제약 및 권한 내에서 작동해야 합니다. 전체 대화 기록이나 다른 서버의 컨텍스트에 접근할 수 없으며, 호스트로부터 전달받은 최소한의 정보만을 사용하여 작업을 수행합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="설계-원칙"&gt;설계 원칙
&lt;/h3&gt;&lt;p&gt;MCP의 아키텍처는 몇 가지 핵심적인 설계 원칙에 기반합니다. 이 원칙들은 프로토콜의 유연성과 견고성을 보장하는 기반이 됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;결합성 (Composability):&lt;/strong&gt; 각 서버는 독립적이고 모듈화된 단위입니다. 호스트는 여러 개의 &lt;u&gt;서버를 조합하여 복잡한 기능을 구성&lt;/u&gt;할 수 있습니다. 예를 들어, 코드 분석 에이전트는 파일 시스템 서버, Git 서버, 정적 분석 서버를 동시에 사용하여 사용자 요청을 처리할 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;격리 (Isolation):&lt;/strong&gt; 서버 간의 엄격한 분리는 MCP의 근본적인 보안 원칙입니다. &lt;span style="background:#fff88f"&gt;호스트가 유일한 컨텍스트 집계자 역할&lt;/span&gt;을 함으로써, 서버는 인가되지 않은 데이터에 접근할 수 없으며 서버 간 상호 간섭으로 인한 위험이 완화됩니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;단순성 및 확장성 (Simplicity and Extensibility):&lt;/strong&gt; 이 설계는 복잡한 &lt;span style="background:#fff88f"&gt;오케스트레이션 로직을 호스트에 배치&lt;/span&gt;하여 서버를 쉽게 구축할 수 있도록 만듭니다. 또한, 프로토콜은 기능 협상 메커니즘을 통해 점진적으로 확장 가능하도록 설계되었습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 아키텍처는 의도적인 트레이드오프를 내포합니다. MCP 사양은 서버 개발 경험을 단순화하는 대신, &lt;span style="background:#fff88f"&gt;복잡성과 책임을 호스트 구현에 집중&lt;/span&gt;시킵니다. &lt;u&gt;서버는 간단하고, 격리되어 있으며, 특정 기능에 집중&lt;/u&gt;합니다. 반면, &lt;u&gt;호스트는 모든 클라이언트를 관리하고, 모든 컨텍스트를 집계하며, 모든 보안 및 동의 정책을 시행&lt;/u&gt;해야 합니다. 결과적으로, MCP 기반 시스템의 보안과 견고성은 프로토콜 자체보다는 &lt;u&gt;호스트 구현의 품질에 의해 결정&lt;/u&gt;됩니다. 호스트는 신뢰, 통제, 그리고 잠재적 실패의 단일 지점(single point of trust and failure)이 됩니다. 핵심 과제는 단순히 서버에 연결하는 것이 아니라, &lt;u&gt;정교하고 안전한 호스트를 구축&lt;/u&gt;하는 데 있습니다.&lt;/p&gt;
&lt;h2 id="데이터-모델"&gt;데이터 모델
&lt;/h2&gt;&lt;p&gt;다음으로 살펴볼 것은 &amp;ldquo;프리미티브(Primitives)&amp;ldquo;입니다. 이전 포스트에서 데이터를 교환할 때 맥락을 보다 세분화된 표현으로 전달하기 위해 사용한다고 언급했습니다. 이는 프리미티브가 AI 애플리케이션과 공유할 수 있는 컨텍스트 정보의 유형과 수행할 수 있는 작업의 범위를 명시적으로 정의하기 때문입니다. 그렇다면 이들이 어떻게 풍부하고 구조화된 컨텍스트 교환을 가능하게 하는지 알아보겠습니다.&lt;/p&gt;
&lt;h3 id="서버-프리미티브"&gt;서버 프리미티브
&lt;/h3&gt;&lt;p&gt;서버가 클라이언트에 컨텍스트를 제공하는 주요 방법은 세 가지 프리미티브를 통해 이루어집니다. 이를 누가 그것의 사용을 통제하는가에 대한 &amp;lsquo;제어 모델&amp;rsquo;에서 살펴보면 아키텍처를 알 수 있습니다.&lt;/p&gt;
&lt;h4 id="도구-tools-행동과-상호작용-활성화-모델-제어"&gt;도구 (Tools): 행동과 상호작용 활성화 (모델 제어)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;개념:&lt;/strong&gt; 도구는 LLM이 발견하고 호출을 결정할 수 있는 실행 가능한 함수입니다. 데이터베이스 쿼리, API 호출, 파일 쓰기와 같이 &lt;u&gt;외부 시스템의 상태를 변경하거나 부작용(side effect)을 일으키는 작업을 수행&lt;/u&gt;하는 데 사용됩니다. 예를 들어, OpenAI의 ChatGPT와 통합하기 위해서는 &lt;code&gt;search&lt;/code&gt;와 &lt;code&gt;fetch&lt;/code&gt;라는 특정 도구를 구현해야 합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;제어 모델:&lt;/strong&gt; &amp;ldquo;모델 제어(Model-controlled)&amp;ldquo;는 &lt;span style="background:#fff88f"&gt;LLM이 사용자의 프롬프트와 도구의 설명을 바탕으로 자율적으로 특정 도구의 호출 여부와 시점을 결정&lt;/span&gt;합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;스키마:&lt;/strong&gt; 도구 정의는 고유한 &lt;code&gt;name&lt;/code&gt;, LLM의 의사결정에 결정적인 역할을 하는 &lt;code&gt;description&lt;/code&gt;, 그리고 인수를 정의하는 &lt;code&gt;inputSchema&lt;/code&gt;를 포함합니다. 결과 검증을 위한 &lt;code&gt;outputSchema&lt;/code&gt;를 선택적으로 포함할 수도 있습니다. &lt;code&gt;inputSchema&lt;/code&gt;는 일반적으로 JSON Schema 객체 형식입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="리소스-resources-수동적-지식-제공-애플리케이션-제어"&gt;리소스 (Resources): 수동적 지식 제공 (애플리케이션 제어)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;개념:&lt;/strong&gt; 리소스는 LLM에 컨텍스트를 제공하는 읽기 전용의 파일과 유사한 데이터 객체입니다. 데이터베이스 스키마, 문서 내용, API 응답 등이 이에 해당하며, &lt;u&gt;부작용을 일으키지 않도록 설계&lt;/u&gt;되었습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;제어 모델:&lt;/strong&gt; &amp;ldquo;애플리케이션 제어(Application-controlled)&amp;rdquo; 또는 &amp;ldquo;사용자 제어(User-controlled)&amp;ldquo;는 &lt;span style="background:#fff88f"&gt;호스트 애플리케이션이나 사용자가&lt;/span&gt; UI 요소(예: &amp;lsquo;@&amp;rsquo; 기호 입력, &amp;lsquo;컨텍스트 추가&amp;rsquo; 버튼 클릭)를 통해 명시적으로 리소스를 컨텍스트에 포함시킬 시점을 결정한다는 것을 의미합니다. &lt;u&gt;LLM은 자율적으로 리소스를 가져오도록 결정하지 않습니다.&lt;/u&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;스키마:&lt;/strong&gt; 리소스는 URI로 식별되며 &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;title&lt;/code&gt;, &lt;code&gt;mimeType&lt;/code&gt;과 같은 메타데이터를 포함합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="프롬프트-prompts-사용자-주도-워크플로우-사용자-제어"&gt;프롬프트 (Prompts): 사용자 주도 워크플로우 (사용자 제어)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;개념:&lt;/strong&gt; 프롬프트는 &lt;u&gt;사용자 상호작용을 안내하거나 복잡한 작업을 구조화&lt;/u&gt;하는, 미리 정의되고 매개변수화 가능한 메시지 템플릿입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;제어 모델:&lt;/strong&gt; &amp;ldquo;사용자 제어(User-controlled)&amp;ldquo;는 일반적으로 &lt;span style="background:#fff88f"&gt;사용자가 UI 명령(예: 슬래시 명령어)을 통해 명시적으로 프롬프트를 선택&lt;/span&gt;한다는 것을 의미합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;스키마:&lt;/strong&gt; 프롬프트 정의는 &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;description&lt;/code&gt;, &lt;code&gt;arguments&lt;/code&gt; 목록, 그리고 템플릿을 구성하는 &lt;code&gt;messages&lt;/code&gt; 배열을 포함합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="클라이언트-프리미티브"&gt;클라이언트 프리미티브
&lt;/h3&gt;&lt;p&gt;MCP는 서버가 클라이언트에게 특정 작업을 요청할 수 있는 프리미티브를 정의합니다. 이는 더욱 복잡하고 &lt;u&gt;양방향적인 워크플로우를 가능&lt;/u&gt;하게 합니다.&lt;/p&gt;
&lt;h4 id="샘플링-sampling-서버의-언어-모델-추론-요청"&gt;샘플링 (Sampling): 서버의 언어 모델 추론 요청
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;개념:&lt;/strong&gt; 서버가 &lt;span style="background:#fff88f"&gt;클라이언트의 LLM에게 추론 작업(예: 텍스트 생성, 콘텐츠 요약)을 수행하고 그 결과를 반환하도록 요청&lt;/span&gt;할 수 있도록 허용합니다. 서버는 모델, 시스템 프롬프트, temperature와 같은 매개변수를 지정할 수 있습니다. 이는 AI 기능이 필요하지만 &lt;u&gt;특정 모델에 종속되지 않고 LLM SDK를 내장하고 싶지 않은 서버&lt;/u&gt;에게 매우 중요합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;사용 사례:&lt;/strong&gt; Python SDK는 이를 위해 &lt;code&gt;ctx.session.create_message&lt;/code&gt; 메서드를 제공합니다. 서버는 자체 API 키나 모델 종속성 없이, 샘플링을 사용하여 &lt;u&gt;자체 데이터를 처리하거나 요약한 후 결과를 반환&lt;/u&gt;할 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="정보-요청-elicitation-human-in-the-loop"&gt;정보 요청 (Elicitation): Human-in-the-loop
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;개념:&lt;/strong&gt; 서버가 워크플로우를 일시 중지하고 호스트의 UI를 통해 &lt;span style="background:#fff88f"&gt;사용자에게 추가 정보나 확인을 요청&lt;/span&gt;할 수 있게 합니다. 서버는 필요한 입력에 대한 스키마를 정의합니다. 호스트가 이 상호작용을 중재하여 사용자 제어와 개인 정보 보호를 보장합니다. 이 기능은 에이전트가 중요한 결정 지점에서 사용자에게 명확한 설명이나 승인을 요청할 수 있는 &lt;u&gt;&amp;ldquo;인간 참여형(human-in-the-loop)&amp;rdquo; 워크플로우를 구현&lt;/u&gt;하는 공식적인 메커니즘입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;사용 사례:&lt;/strong&gt; Python SDK 예제에서는 &lt;code&gt;book_table&lt;/code&gt; 도구가 특정 날짜에 예약이 불가능할 경우 &lt;code&gt;ctx.elicit&lt;/code&gt;을 사용하여 사용자에게 대체 날짜를 묻는 것을 보여줍니다. 다단계 인증이 필요한 도구는 정보 요청을 사용하여 서버가 직접 원시 입력을 처리하지 않고도 사용자에게 안전하게 코드를 입력하도록 요청할 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="루트-roots-호스트-환경-상호작용"&gt;루트 (Roots): 호스트 환경 상호작용
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;개념&lt;/strong&gt;: 서버가 허가를 받아 접근할 수 있는 &lt;span style="background:#fff88f"&gt;호스트의 로컬 환경&lt;/span&gt;에 대한 진입점입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;사용 사례:&lt;/strong&gt; 서버는 파일 시스템 디렉토리의 정보를 요청할 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="데이터-스키마와-검증-json-schema"&gt;데이터 스키마와 검증: JSON Schema
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;스키마:&lt;/strong&gt; MCP 사양은 TypeScript 스키마 파일(&lt;code&gt;schema.ts&lt;/code&gt;)을 통해 정의됩니다. 이는 프로토콜의 &lt;span style="background:#fff88f"&gt;모든 데이터 구조에 대한 단일 진실 공급원&lt;/span&gt;(single source of truth) 역할을 합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;구현:&lt;/strong&gt; 실제 개발에서는 TypeScript의 Zod나 Python의 Pydantic과 같은 라이브러리를 사용하여 도구 인수 및 기타 프리미티브의 스키마를 정의하고 검증합니다. 이는 &lt;u&gt;타입 안정성을 보장하고 견고한 오류 처리&lt;/u&gt;를 가능하게 합니다. 도구의 &lt;code&gt;inputSchema&lt;/code&gt;는 일반적으로 JSON Schema 객체로 정의되어 언어에 구애받지 않는 상호 운용성을 제공합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;프리미티브의 제어 모델 구분은 MCP에 내장된 근본적인 보안 및 사용자 경험(UX) 설계 패턴입니다. 이는 개발자가 AI 에이전트가 특정 기능에 대해 가져야 할 자율성의 수준을 추론할 수 있는 프레임워크를 제공하여, 시스템이 얼마나 안전하고 예측 가능하게 작동할지에 직접적인 영향을 미칩니다. 예를 들어, &lt;u&gt;민감한 작업은 LLM이 예기치 않게 호출할 수 있는 &amp;lsquo;도구&amp;rsquo;보다는 명시적인 사용자 조치가 필요한 &amp;lsquo;리소스&amp;rsquo;로 노출&lt;/u&gt;해야 합니다. 이처럼 제어 모델을 올바르게 선택하는 것은 안전하고 신뢰할 수 있는 AI 에이전트를 설계하는 데 있어 가장 중요한 아키텍처 결정 중 하나입니다.&lt;/p&gt;
&lt;h2 id="통신"&gt;통신
&lt;/h2&gt;&lt;p&gt;앞에서 데이터 모델(&amp;ldquo;무엇을&amp;rdquo;)을 알아봤다면, 이제는 통신 메커니즘(&amp;ldquo;어떻게&amp;rdquo;)으로 초점을 전환합니다. MCP의 기본 프로토콜 및 전송 계층, 상태 저장 세션 생명주기까지 전체 통신 시퀀스를 살펴보겠습니다.&lt;/p&gt;
&lt;h3 id="상태-에이전트-워크플로우-특화"&gt;상태: 에이전트 워크플로우 특화
&lt;/h3&gt;&lt;p&gt;RESTful API는 상태 비저장(stateless) 방식으로 작동합니다. 각 요청은 이전 요청과 독립적으로 처리되며, 클라이언트는 여러 단계에 걸친 &lt;u&gt;작업의 상태와 컨텍스트를 스스로 관리해야 할 책임&lt;/u&gt;이 있습니다.&lt;/p&gt;
&lt;p&gt;이는 간단한 데이터 조회에는 효율적일 수 있으나, 여러 단계의 &lt;u&gt;상호작용이 필요한 복잡한 작업을 수행하는 AI 에이전트에게는 상당한 부담&lt;/u&gt;입니다. 에이전트 또는 클라이언트 측 오케스트레이터가 모든 상태를 기억하고 매 요청마다 전체 컨텍스트를 다시 전송하는 유일한 상태 관리자가 되면서 비효율적이고 시스템을 취약하게 만드는 원인이 됩니다.&lt;/p&gt;
&lt;p&gt;반면, MCP는 &lt;strong&gt;상태를 유지하는(stateful) 영속적인 연결(persistent connections)&lt;/strong&gt; 을 기반으로 설계되었습니다. 이는 일련의 개별적인 요청-응답이 아닌, 마치 웹소켓(WebSocket) 세션과 유사한 지속적인 양방향 통신 채널을 구축하는 것을 의미합니다.&lt;/p&gt;
&lt;p&gt;상태 유지 연결은 다단계 작업 수행에 있어 결정적인 장점을 가집니다. 서버는 진행 중인 워크플로우의 컨텍스트를 세션 내에서 유지할 수 있으므로, 클라이언트는 &lt;u&gt;매번 전체 컨텍스트를 다시 보낼 필요가 없습니다.&lt;/u&gt; 인지적 부담의 일부를 도구 서버로 오프로드합니다. 이를 통해 &lt;span style="background:#fff88f"&gt;도구 자체가 메모리를 가지고 에이전트를 특정 프로세스로 안내하는 등 훨씬 더 정교한 상호작용이 가능&lt;/span&gt;해집니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MCP 로드맵에서도 &lt;u&gt;연결 끊김 및 재연결에 대한 탄력적인 처리와 장기 실행 작업을 지원하는 것이 핵심 우선순위&lt;/u&gt;로 명시되어 있으며, 이는 상태 유지가 핵심 설계임을 의미합니다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;이러한 아키텍처적 선택은 기술적 편의를 넘어, 에이전트와 도구 간의 상호작용 모델을 단순한 &amp;lsquo;요청-응답&amp;rsquo;에서 &lt;strong&gt;&amp;lsquo;대화형 상호작용&amp;rsquo; 모델&lt;/strong&gt;로 전환시킵니다. 그리고 AI 에이전트와 도구 간의 관계를 &amp;lsquo;파트너십&amp;rsquo;으로 발전시키는 &amp;ldquo;협력적 인지(collaborative cognition)&amp;ldquo;라는 새로운 패러다임을 가능하게 합니다. 도구는 &lt;u&gt;더 이상 수동적으로 호출되는 함수가 아니라, 문제 해결 과정에 능동적으로 참여하는 주체&lt;/u&gt;가 됩니다. 이는 고급 에이전트 행동을 위한 필수 전제 조건입니다.&lt;/p&gt;
&lt;p&gt;구체적으로 살펴보겠습니다. 상태 비저장 API는 거래적(transactional)입니다. 에이전트가 도구에게 명령하면, 과거 상호작용에 대한 기억이 없는 도구는 그저 명령을 수행합니다. 그러나 MCP의 상태 유지 연결은 서버가 세션의 컨텍스트를 &amp;ldquo;기억&amp;quot;할 수 있음을 의미합니다. 예를 들어, &amp;ldquo;순차적 사고(Sequential Thinking)&amp;rdquo; 서버는 동적인 문제 해결 과정을 추적할 수 있습니다.&lt;/p&gt;
&lt;p&gt;여기에 &lt;code&gt;Elicitation&lt;/code&gt; 및 &lt;code&gt;Sampling&lt;/code&gt;과 같은 서버 주도 상호작용 기능은 &lt;u&gt;서버가 통신을 시작하여 에이전트에게 추가 정보를 요청하거나 추론 작업을 수행하도록 요청&lt;/u&gt;할 수 있게 합니다. 이는 강력한 피드백 루프를 형성합니다. 에이전트가 도구에 도움을 요청하면, 도구는 자체 상태와 전문화된 로직을 사용하여 추가 정보가 필요하다고 판단하고 에이전트에게 다시 질문(&lt;code&gt;Elicitation&lt;/code&gt;)하거나, 창의적인 단계가 필요하다고 판단하여 에이전트에게 텍스트 생성을 요청(&lt;code&gt;Sampling&lt;/code&gt;)할 수 있습니다. 결과적으로 복잡한 문제를 해결하는 데 필요한 인지적 부하가 분산됩니다.&lt;/p&gt;
&lt;p&gt;정리하면, LLM은 일반적인 추론과 언어를 처리하고, 전문화된 MCP 서버는 &lt;span style="background:#fff88f"&gt;도메인 특화 로직, 상태 및 상호작용 흐름을 처리&lt;/span&gt;합니다. 이 협력 모델은 LLM이 모든 것을 관리해야 하는 모델보다 훨씬 더 강력하고 효율적입니다.&lt;/p&gt;
&lt;h3 id="세션-생명주기"&gt;세션 생명주기
&lt;/h3&gt;&lt;p&gt;생명주기의 핵심은 &amp;lsquo;기능 협상&amp;rsquo; 과정으로, 클라이언트와 서버가 서로가 제공하고 지원하는 기능을 동적으로 확인하고 합의하는 절차입니다.&lt;/p&gt;
&lt;h4 id="초기화-핸드셰이크-및-기능-협상"&gt;초기화: 핸드셰이크 및 기능 협상
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;초기화 (&lt;code&gt;initialize&lt;/code&gt;):&lt;/strong&gt; 연결이 시작되면, 클라이언트는 먼저 &lt;code&gt;initialize&lt;/code&gt; 요청을 서버에 보냅니다. 이 요청에는 &lt;u&gt;클라이언트가 지원하는 프로토콜 버전 정보와 함께, 클라이언트가 제공할 수 있는 기능&lt;/u&gt;(예: 서버로부터 LLM 추론 요청을 받을 수 있는 &lt;code&gt;sampling&lt;/code&gt; 기능 지원 여부)&lt;u&gt;에 대한 정보가 포함&lt;/u&gt;됩니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;기능 협상 (Response to &lt;code&gt;initialize&lt;/code&gt;):&lt;/strong&gt; &lt;code&gt;initialize&lt;/code&gt; 요청을 받은 서버는 &lt;u&gt;자신의 정보(이름, 버전 등)와 함께 자신이 제공할 수 있는 기능의 목록을 담아 응답&lt;/u&gt;합니다. 예를 들어, 서버는 자신이 &lt;code&gt;tools&lt;/code&gt;와 &lt;code&gt;resources&lt;/code&gt; 프리미티브를 제공하는지, 그리고 도구 목록이 변경될 때 &lt;code&gt;listChanged&lt;/code&gt; 알림을 보낼 수 있는지 여부를 &lt;code&gt;capabilities&lt;/code&gt; 객체에 담아 클라이언트에 알립니다. 이 교환 과정을 통해 양측은 세션에서 &lt;span style="background:#fff88f"&gt;어떤 종류의 상호작용이 가능한지에 대해 명시적으로 합의&lt;/span&gt;하게 됩니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;초기화 완료 (&lt;code&gt;initialized&lt;/code&gt;):&lt;/strong&gt; 서버로부터 기능 목록을 성공적으로 수신한 클라이언트는 &lt;code&gt;initialized&lt;/code&gt;&lt;u&gt; 알림을 서버에 보내 핸드셰이크가 완료되었음을 알립니다. &lt;/u&gt;이 시점부터 본격적인 상호작용이 시작됩니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="운영-동적-컨텍스트-교환"&gt;운영: 동적 컨텍스트 교환
&lt;/h4&gt;&lt;p&gt;이 단계에서는 클라이언트와 서버가 초기화 단계에서 협상된 기능에 따라 요청, 응답, 알림을 자유롭게 교환합니다. 예를 들어, 클라이언트는 &lt;code&gt;tools/list&lt;/code&gt;로 사용 가능한 도구를 확인하고 &lt;code&gt;tools/call&lt;/code&gt;로 특정 도구를 실행할 수 있으며, 서버는 &lt;code&gt;notifications/prompts/list_changed&lt;/code&gt; 알림을 보내 프롬프트 목록의 변경 사항을 알릴 수 있습니다.&lt;/p&gt;
&lt;h4 id="종료-정상적인-연결-해제"&gt;종료: 정상적인 연결 해제
&lt;/h4&gt;&lt;p&gt;연결은 기본 전송 메커니즘을 사용하여 정상적으로 종료됩니다. &lt;code&gt;stdio&lt;/code&gt;의 경우 &lt;code&gt;stdin&lt;/code&gt; 스트림을 닫고, HTTP 세션의 경우 &lt;code&gt;DELETE&lt;/code&gt; 요청을 보내는 방식입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font color="#245bdb"&gt;&lt;b&gt;NOTE: 상태 저장 세션과 기능 협상 채택의 목적&lt;/b&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;초기 핸드셰이크는 단순한 인증 절차가 아니라, 세션의 &amp;ldquo;계약 조건&amp;quot;을 설정하는 공식적인 협상 과정입니다. 이 상태 저장 및 협상된 컨텍스트는 &lt;code&gt;listChanged&lt;/code&gt;와 같은 동적 업데이트 알림, &lt;code&gt;sampling&lt;/code&gt;과 같은 서버 주도 요청, 세션 내 효율적인 컨텍스트 캐싱 등 상태 비저장 모델에서는 불가능한 &lt;u&gt;고급 기능을 가능&lt;/u&gt;하게 합니다.&lt;/p&gt;
&lt;p&gt;이는 클라이언트와 서버가 독립적으로 개발되고 시간이 지남에 따라 새로운 기능을 추가할 수 있게 하면서도, 핸드셰이크를 통해 &lt;u&gt;하위 호환성을 보장하고 지원되지 않는 작업으로 인한 런타임 오류를 방지&lt;/u&gt;합니다. 이것이 프로토콜의 확장성과 장기적인 생존 가능성의 핵심입니다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id="json-rpc-20"&gt;JSON-RPC 2.0
&lt;/h3&gt;&lt;p&gt;MCP는 메시징 형식을 위해 널리 확립된 &lt;strong&gt;JSON-RPC 2.0&lt;/strong&gt; 프로토콜을 기반으로 구축되었습니다.3 이는 요청, 응답 및 오류 처리를 위한 표준화된 구조를 제공하여 프로토콜의 안정성과 예측 가능성을 높입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;요청(Request):&lt;/strong&gt; 요청 메시지는 클라이언트가 서버의 특정 기능을 호출하기 위해 전송하는 통신의 시작점입니다. 이 메시지는 &lt;code&gt;jsonrpc&lt;/code&gt;, &lt;code&gt;method&lt;/code&gt;, &lt;code&gt;params&lt;/code&gt;, 그리고 고유한 &lt;code&gt;id&lt;/code&gt; 필드를 포함합니다. &lt;code&gt;method&lt;/code&gt; 필드는 &lt;code&gt;tools/call&lt;/code&gt;이나 &lt;code&gt;resources/list&lt;/code&gt;와 같이 호출할 함수의 이름을 명시합니다. 가장 중요한 것은 &lt;code&gt;id&lt;/code&gt; 필드로, 모든 요청을 고유하게 식별하여 비동기적인 환경에서도 요청과 응답을 정확하게 연결하는 역할을 합니다. &lt;code&gt;id&lt;/code&gt;의 존재는 MCP가 단순한 단방향 호출이 아닌, &lt;span style="background:#fff88f"&gt;상태를 추적하고 관리하는 상태 기반(stateful) 상호작용을 전제로 설계&lt;/span&gt;되었음을 보여줍니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;응답(Response):&lt;/strong&gt; 서버는 요청을 처리한 후, 반드시 해당 요청의 &lt;code&gt;id&lt;/code&gt;&lt;span style="background:#fff88f"&gt;를 포함하는 응답 메시지를 반환&lt;/span&gt;합니다. 작업이 성공했을 경우 &lt;code&gt;result&lt;/code&gt; 필드에 결과 데이터를 보내고, 실패했을 경우에는 &lt;code&gt;error&lt;/code&gt; 필드에 에러 코드와 메시지를 보냅니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;알림(Notification):&lt;/strong&gt; 알림은 요청과 달리 &lt;code&gt;id&lt;/code&gt; 필드가 없어 &lt;span style="background:#fff88f"&gt;응답을 요구하지 않는 단방향 메시지&lt;/span&gt;입니다. 이는 서버가 &lt;u&gt;자신의 상태 변화를 클라이언트에게 능동적으로 전파&lt;/u&gt;해야 할 때 사용합니다. 예를 들어, 서버에 새로운 도구가 추가되거나 기존 도구가 제거되었을 때, 서버는 &lt;code&gt;notifications/tools/list_changed&lt;/code&gt; 알림을 보내 클라이언트가 최신 도구 목록을 유지할 수 있도록 합니다. 이 메커니즘은 MCP 환경을 정적인 상태가 아닌, &lt;u&gt;동적으로 변화하고 반응하는 생태계로 만드는 핵심 요소&lt;/u&gt;로 작용합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font color="#245bdb"&gt;&lt;b&gt;TIP: 도구 변동 알림이 필요한 이유&lt;/b&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;성능 향상을 위해 호스트는 &lt;span style="background:#fff88f"&gt;서버로부터 받은 도구 목록을 캐시&lt;/span&gt;합니다. 이 캐시가 오래된 정보가 되는 것을 방지하기 위해, 서버는 초기화 시 &lt;code&gt;listChanged: true&lt;/code&gt; 기능을 선언할 수 있습니다.&lt;/p&gt;
&lt;p&gt;만약 서버에서 사용 가능한 도구가 변경되면, 서버는 &lt;code&gt;notifications/tools/list_changed&lt;/code&gt; &lt;u&gt;알림을 보냅니다.&lt;/u&gt; 이 알림을 받은 호스트는 자신의 캐시가 오래되었음을 인지하고 &lt;code&gt;tools/list&lt;/code&gt;를 다시 요청하여 도구 목록을 갱신합니다.&lt;/p&gt;
&lt;p&gt;이 이벤트 기반 모델은 &lt;u&gt;지속적으로 서버 상태를 확인하는 폴링(polling) 방식보다 훨씬 효율적&lt;/u&gt;입니다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id="전송-방식"&gt;전송 방식
&lt;/h3&gt;&lt;p&gt;MCP는 배포 시나리오와 요구사항에 맞게 전송 방식을 정할 수 있습니다. MCP 프로토콜 자체는 특정 전송 방식에 종속되지 않지만, 두 가지 표준 메커니즘을 정의하여 대부분의 사용 사례를 지원합니다.&lt;/p&gt;
&lt;p&gt;이러한 이중화된 전송 메커니즘은 MCP가 &amp;lsquo;보안&amp;rsquo;을 중시하는 로컬 환경과 &amp;lsquo;확장성&amp;rsquo;을 중시하는 원격 클라우드 환경이라는 두 가지 핵심 가치를 동시에 추구하기 위한 의도적인 설계적 타협입니다. 개발자는 자신의 사용 사례에 맞춰 최적의 전송 방식을 선택할 수 있지만, 이는 동시에 MCP 클라이언트(호스트)가 두 가지 상이한 통신 모델을 모두 안정적으로 처리해야 하는 기술적 과제를 가집니다.&lt;/p&gt;
&lt;h4 id="stdio-표준-입출력"&gt;&lt;code&gt;stdio&lt;/code&gt; (표준 입출력)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;메커니즘:&lt;/strong&gt; 이 방식은 MCP &lt;span style="background:#fff88f"&gt;서버가 호스트 애플리케이션(예: IDE, 데스크톱 앱)의 로컬 서브프로세스로 실행될 때&lt;/span&gt; 사용됩니다. 통신은 운영체제의 표준 입력(stdin)과 표준 출력(stdout) 스트림을 통해 이루어집니다. 가장 큰 장점은 네트워크 스택을 거치지 않아 &lt;u&gt;지연 시간이 마이크로초 단위로 극도로 낮고&lt;/u&gt;, 운영체제 수준의 프로세스 격리를 통해 외부 네트워크로부터의 접근이 원천적으로 차단되어 &lt;u&gt;보안성이 매우 높다&lt;/u&gt;는 점입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;사용 사례:&lt;/strong&gt; VS Code나 Claude Desktop과 같은 개발 도구에서 사용자의 로컬 파일 시스템에 접근하거나 로컬 스크립트를 실행하는 등 민감한 작업을 안전하고 신속하게 처리하는 데 최적화되어 있습니다. &lt;span style="background:#fff88f"&gt;단일 사용자, 로컬 전용 시나리오&lt;/span&gt;에 대해 간단하고 안전한 통신을 제공합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="streamable-http-레거시-httpsse-대체"&gt;&lt;code&gt;Streamable HTTP&lt;/code&gt; (레거시 &lt;code&gt;HTTP+SSE&lt;/code&gt; 대체)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;메커니즘:&lt;/strong&gt; 원격 또는 네트워크 서버에 사용됩니다. 단일 표준 HTTP 연결을 통해 더 확장 가능하고 효율적인 양방향 통신을 가능하게 합니다. 주로 청크 분할 전송 인코딩(chunked transfer encoding)을 사용합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;사용 사례:&lt;/strong&gt; 클라우드 배포(예: AWS Lambda) 및 엄격한 방화벽 규칙이 있는 엔터프라이즈 네트워크 환경에 적합합니다. 웹 서비스, 서드파티 API 또는 다중 사용자/원격 서비스 연결에 필수적입니다. &lt;code&gt;Mcp-Session-Id&lt;/code&gt; 헤더를 통해 &lt;span style="background:#fff88f"&gt;상태 저장 세션을 지원&lt;/span&gt;하여, 여러 요청에 걸쳐 컨텍스트를 유지할 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;전송 계층이 STDIO/SSE에서 Streamable HTTP로 발전한 것은 MCP가 개발자 중심의 로컬 우선 도구에서 엔터프라이즈급 클라우드 네이티브 프레임워크로 전략적으로 전환하고 있음을 보여줍니다. Streamable HTTP는 단방향 통신이라는 SSE의 한계와 웹소켓의 운영 복잡성을 극복하고, &lt;u&gt;원격 보안 통신을 위한 강력하고 널리 호환되는 솔루션&lt;/u&gt;을 제공합니다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font color="#245bdb"&gt;&lt;b&gt;NOTE: &lt;code&gt;HTTP+SSE&lt;/code&gt; 방식이 대체된 이유&lt;/b&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Streamable HTTP&lt;/code&gt; 이전 &lt;u&gt;원격 서버와의 통신&lt;/u&gt;을 위해 설계되었습니다. 클라이언트에서 서버로의 요청은 일반적인 HTTP POST 요청을 사용하고, 서버에서 클라이언트로의 지속적인 데이터 스트리밍은 Server-Sent Events(SSE)를 통해 이루어집니다.&lt;/p&gt;
&lt;p&gt;SSE는 &lt;span style="background:#fff88f"&gt;단방향(서버→클라이언트) 통신&lt;/span&gt; 채널을 오랫동안 유지하며 업데이트를 푸시하는 데 특화되어 있습니다. 이 방식은 기존 웹 인프라(프록시, 방화벽, 로드밸런서)와 완벽하게 호환되므로, Stripe, GitHub, Sentry 등 클라우드 기반의 원격 SaaS API를 MCP 서버로 연동하는 데 이상적입니다.&lt;/p&gt;
&lt;p&gt;다만, 양방향 통신을 위해 &lt;u&gt;요청(HTTP POST)과 응답 스트림(SSE)을 별도의 채널로 관리해야 하는 복잡성이 존재&lt;/u&gt;했고, 최신 MCP 사양에서는 이러한 복잡성을 줄이기 위해 단일 HTTP 연결 내에서 양방향 스트리밍을 지원하는 &lt;code&gt;Streamable HTTP&lt;/code&gt;&lt;u&gt;로의 통합을 추진&lt;/u&gt;하고 있습니다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font color="#245bdb"&gt;&lt;b&gt;NOTE: &lt;code&gt;WebSockets&lt;/code&gt;&lt;/b&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;최대의 상호작용성이 요구될 경우 사용 가능한 전송 방식입니다. 완전한 양방향(full-duplex) 통신을 제공하여 스트리밍 데이터, 진행 상황 업데이트, 협업 상호작용 등이 포함된 복잡한 AI 워크플로우에 특히 유용할 수 있습니다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;특성&lt;/th&gt;
&lt;th&gt;&lt;code&gt;stdio&lt;/code&gt; (Standard Input/Output)&lt;/th&gt;
&lt;th&gt;&lt;code&gt;HTTP+SSE&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;Streamable HTTP&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;WebSockets&lt;/code&gt; (대안)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;통신 모델&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;양방향&lt;/td&gt;
&lt;td&gt;단방향 (서버→클라이언트)&lt;/td&gt;
&lt;td&gt;양방향 (단일 연결)&lt;/td&gt;
&lt;td&gt;완전 양방향 (Full-duplex)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;주요 장점&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- 매우 낮은 지연 시간 - 네트워크 설정 불필요 - OS 수준의 높은 보안 (샌드박싱)&lt;/td&gt;
&lt;td&gt;- 기존 웹 인프라와 호환 - 실시간 결과 스트리밍 가능&lt;/td&gt;
&lt;td&gt;- 기존 웹 인프라와 호환 - 서버리스 환경 지원 - 실시간 결과 스트리밍 가능&lt;/td&gt;
&lt;td&gt;- 진정한 실시간 양방향 통신 - 단일 연결 관리로 인한 단순성&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;주요 단점/고려사항&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- 원격 서버 연결 불가 - 호스트가 서버 프로세스 생명주기 관리 필요&lt;/td&gt;
&lt;td&gt;- 양방향 통신을 위한 채널 관리 복잡성 (HTTP+SSE) - 장기 연결을 위한 프록시/로드밸런서 설정 필요&lt;/td&gt;
&lt;td&gt;- 장기 연결을 위한 프록시/로드밸런서 설정 필요&lt;/td&gt;
&lt;td&gt;- 일부 기업 네트워크에서 제한될 수 있음 - 초기 핸드셰이크 오버헤드 존재&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;대표 사용 사례&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- IDE 플러그인 (VS Code, Cursor) - 로컬 파일 시스템 접근 - 데스크톱 AI 어시스턴트 (Claude Desktop)&lt;/td&gt;
&lt;td&gt;원격 API 연동 (Stripe, Sentry) - 클라우드 기반 데이터 소스 연결 - 웹 브라우저 기반 클라이언트&lt;/td&gt;
&lt;td&gt;- 원격 API 연동 (Stripe, Sentry) - 클라우드 기반 데이터 소스 연결 - 웹 브라우저 기반 클라이언트&lt;/td&gt;
&lt;td&gt;- 고빈도 상호작용이 필요한 채팅 애플리케이션 - 실시간 협업 도구&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;지연 시간&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;매우 낮음&lt;/td&gt;
&lt;td&gt;낮음-중간&lt;/td&gt;
&lt;td&gt;낮음-중간&lt;/td&gt;
&lt;td&gt;매우 낮음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;확장성&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;제한적 (단일 머신)&lt;/td&gt;
&lt;td&gt;중간&lt;/td&gt;
&lt;td&gt;높음&lt;/td&gt;
&lt;td&gt;높음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;네트워크 호환성&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;해당 없음 (로컬)&lt;/td&gt;
&lt;td&gt;표준 HTTP/S 포트&lt;/td&gt;
&lt;td&gt;표준 HTTP/S 포트&lt;/td&gt;
&lt;td&gt;별도 프로토콜/포트 필요 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;현재 상태&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;활성&lt;/td&gt;
&lt;td&gt;사용되지 않음 (Deprecated)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;현재 표준&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;고려 대상&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id="마치며"&gt;마치며
&lt;/h2&gt;&lt;p&gt;이번 포스트에서는 MCP 생태계를 이루는 각 요소와 그 역할, 데이터 교환을 위한 각 프리미티브의 목적, MCP 통신의 특징과 그 목적을 확인했습니다. MCP 설계 과정에 담긴 철학을 확인하고 이에 맞게 아키텍처를 설계했을 때 향후 업데이트 및 생태계의 지원을 기대할 수 있다고 생각합니다.&lt;/p&gt;
&lt;p&gt;포스트를 위한 자료를 찾아보면서, 내부 동작이 어떻게 이루어지는지 자세히 이해할 수 있었습니다. 또한 MCP가 상태를 저장하는 목적을 명확하게 알 수 있었습니다. 여러 에이전트가 공통으로 사용할 수 있는 기능들을 어떻게 재사용할 것인지 고민이 있었는데, MCP에 담긴 도메인 로직 구현의 철학에서 그에 대한 답변을 얻은 것 같습니다.&lt;/p&gt;
&lt;p&gt;다음 포스트에서는 MCP를 비즈니스 환경에서 설계하고 구현할 때, 보안 등의 측면에서 고려해야 할 점에 대해 살펴보겠습니다. 이후에는 MCP의 아키텍처와 철학, 고려할 점을 반영하여 개발하는 과정을 작성하려 합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;본 포스트는 Google Gemini의 응답을 기반으로 저의 의견을 반영하여 다시 작성했습니다.&lt;/p&gt;&lt;/blockquote&gt;</description></item><item><title>MCP의 개념</title><link>https://yeonhl.github.io/systems/mcp/concept/</link><pubDate>Mon, 11 Aug 2025 19:03:00 +0000</pubDate><guid>https://yeonhl.github.io/systems/mcp/concept/</guid><description>&lt;h2 id="개요"&gt;개요
&lt;/h2&gt;&lt;p&gt;MCP 이전에도 LLM은 도구를 사용하고 있었고, 외부 데이터에 접근하고 있었습니다. 그렇다면 MCP는 어떤 문제를 해결하기 위해 등장했을까요?&lt;/p&gt;
&lt;p&gt;MCP가 등장하기 전에는, M개의 AI 모델을 N개의 외부 도구 또는 데이터 소스에 연결하기 위해 각각의 통합, 즉 M×N개의 커넥터를 개발해야 했습니다. 그리고 각각의 맞춤형 커넥터는 개발, 테스트, 유지보수, 보안 검토를 위해 재사용이 불가능한 상당한 엔지니어링 자원을 요구했습니다. 이는 재사용이 불가능하고 감사가 어려웠으며, 기반이 되는 API나 모델이 업데이트될 때마다 쉽게 손상되어 단편적이고 예측 불가능한 시스템을 만들었고, &amp;ldquo;높은 통합 비용과 개발자 오버헤드&amp;rdquo;, &amp;ldquo;중복된 개발 노력&amp;rdquo;, 그리고 &amp;ldquo;과도한 유지보수 부담&amp;quot;으로 이어졌습니다. (이 문제를 &amp;lsquo;M×N 문제&amp;rsquo;라고 합니다.) 이 문제는 소프트웨어 개발의 비효율성을 넘어 AI 시스템의 확장을 근본적으로 저해하는 장벽이었습니다.&lt;/p&gt;
&lt;p&gt;이 포스트에서는 MCP가 어떤 특징을 갖고, 어떤 변화를 가져왔는지 살펴보겠습니다.&lt;/p&gt;
&lt;h2 id="mcp의-목표"&gt;MCP의 목표
&lt;/h2&gt;&lt;h3 id="m-x-n-통합-위기-해결"&gt;M x N 통합 위기 해결
&lt;/h3&gt;&lt;p&gt;MCP는 &amp;ldquo;M×N 문제&amp;quot;를 더 관리하기 쉬운 &amp;ldquo;M+N 문제&amp;quot;로 전환합니다. 도구 제작자는 N개의 표준화된 MCP 서버를 구축하고, 애플리케이션 개발자는 M개의 MCP 클라이언트를 구축합니다. 이는 재사용 가능하고 상호 운용 가능한 계층을 생성하여, 개발자들이 맞춤형 통합을 만들고 유지하는 데 드는 시간을 절약합니다.&lt;/p&gt;
&lt;p&gt;이는 단순히 함수 호출을 대체하는 것이 아니라, &lt;u&gt;더 일관되고 단순한 개발 패러다임을 구축&lt;/u&gt;하는 것입니다. 이 프로토콜은 AI 애플리케이션이 외부 도구, 데이터 소스, 시스템과 연결되는 방식을 표준화하여 분편화된 통합 워크플로우 문제를 해결하기 위해 설계되었습니다.&lt;/p&gt;
&lt;h3 id="에이전트-지원"&gt;에이전트 지원
&lt;/h3&gt;&lt;p&gt;주요 목표 중 하나는 더 정교하고 자율적인 AI 에이전트의 개발을 촉진하는 것입니다. MCP는 &lt;u&gt;다양한 도구와 데이터셋에 걸쳐 컨텍스트를 유지&lt;/u&gt;함으로써 다단계 &amp;ldquo;사고의 연쇄(chain-of-thought)&amp;rdquo; 추론을 지원하고, 에이전트가 사용자를 대신하여 복잡한 작업을 수행합니다.&lt;/p&gt;
&lt;p&gt;이 프로토콜은 AI 기능을 &amp;ldquo;레고 블록&amp;quot;처럼 조합하고 맞출 수 있는 모듈식 아키텍처를 장려합니다. 문서 조회와 메시징 API를 결합하는 등 여러 도구를 조율하여 더 복잡한 목표를 달성합니다.&lt;/p&gt;
&lt;p&gt;이 비전은 다중 에이전트 시스템까지 확장됩니다. 목표는 모델이 최신 컨텍스트에 접근하여 AI 성능과 관련성을 향상하는 것입니다. 모델을 고립 상태에서 벗어나게 하여, 더 신뢰할 수 있는 결과물을 제공합니다.&lt;/p&gt;
&lt;h2 id="mcp의-특징"&gt;MCP의 특징
&lt;/h2&gt;&lt;h3 id="원칙"&gt;원칙
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;상호 운용성 (Interoperability):&lt;/strong&gt; 벤더 종속성(vendor lock-in)을 깨고 &lt;span style="background:#fff88f"&gt;MCP를 준수하는 모든 모델이 MCP를 준수하는 모든 도구와 작동&lt;/span&gt;할 수 있도록 합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;구성 가능성 (Composability):&lt;/strong&gt; 개발자들이 모듈식 &amp;ldquo;플러그 앤 플레이&amp;rdquo; 방식으로 도구와 데이터 소스를 결합하여 복잡하고 다단계적인 에이전트 워크플로우를 쉽게 구축할 수 있도록 합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;발견 가능성 (Discoverability):&lt;/strong&gt; AI 에이전트가 사전에 프로그래밍된 지식 없이도 런타임에 &lt;span style="background:#fff88f"&gt;서버에 동적으로 질의&lt;/span&gt;하여(&amp;ldquo;어떤 도구를 제공하나요?&amp;rdquo;) 그 능력을 파악하고, 더 큰 적응성을 가능하게 합니다. 이는 특히 정적인 API와의 핵심적인 차이점입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="구성-요소"&gt;구성 요소
&lt;/h3&gt;&lt;p&gt;MCP는 세 가지 핵심 구성 요소로 이루어집니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;호스트(Host):&lt;/strong&gt; Claude Desktop이나 IDE와 같이 여러 클라이언트를 관리하고 사용자 권한을 집행하는 조정자 역할의 &lt;span style="background:#fff88f"&gt;LLM 애플리케이션&lt;/span&gt;입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;클라이언트(Client):&lt;/strong&gt; 단일 서버와 1:1 &lt;span style="background:#fff88f"&gt;상태 저장(stateful) 연결을 유지&lt;/span&gt;하는 전용 커넥터입니다. 메시지 라우팅, 프로토콜 버전 협상, 서버의 기능 관리 등을 책임집니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서버(Server):&lt;/strong&gt; 외부 세계의 기능(&lt;code&gt;tools&lt;/code&gt;, &lt;code&gt;resources&lt;/code&gt;, &lt;code&gt;prompts&lt;/code&gt;)을 &lt;span style="background:#fff88f"&gt;AI 모델에게 노출&lt;/span&gt;하는 구성 요소입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 아키텍처의 핵심은 &lt;strong&gt;결합성(Composability)&lt;/strong&gt; 입니다. 하나의 애플리케이션이 &lt;u&gt;클라이언트와 서버 역할을 동시에 수행할 수 있어&lt;/u&gt;, 계층적인 에이전트 시스템 구축이 가능합니다. 예를 들어, 주 에이전트(클라이언트)가 특정 작업을 전문 하위 에이전트(서버)에게 위임하고, 이 하위 에이전트는 다시 다른 MCP 서버(파일 시스템 서버 등)의 클라이언트가 되어 필요한 도구를 호출하는 복잡한 워크플로우를 구성할 수 있습니다.&lt;/p&gt;
&lt;h3 id="통신"&gt;통신
&lt;/h3&gt;&lt;p&gt;MCP는 구조화된 통신을 위해 명확한 역할을 가진 클라이언트-서버 모델을 채택합니다.&lt;/p&gt;
&lt;p&gt;클라이언트는 서버와 일대일 연결을 유지하며, 안전하고 격리된 통신 채널 역할을 합니다. 호스트가 요청을 조율하지만, 모든 통신은 클라이언트를 통해 중개됩니다. 이는 서버와 호스트가 직접 통신하지 않도록 보장하는 핵심적인 보안 설계 원칙입니다.&lt;/p&gt;
&lt;p&gt;MCP는 클라이언트와 서버 간의 연결에 대해 예측 가능한 동작을 보장하기 위해 엄격한 3단계 생명주기를 강제합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;초기화(Initialization):&lt;/strong&gt; 클라이언트와 서버가 서로 지원하는 프로토콜 버전과 기능을 교환하고 협상합니다. 이는 런타임에 사용 가능한 기능을 동적으로 발견하고 호환성을 보장하는 매우 중요한 단계입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;작동(Operation):&lt;/strong&gt; 협상된 기능의 범위 내에서 정상적인 통신이 이루어집니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;종료(Shutdown):&lt;/strong&gt; 연결을 정상적으로 종료하는 절차를 따릅니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="전송-계층"&gt;전송 계층
&lt;/h3&gt;&lt;p&gt;프로토콜 자체는 가볍고 널리 이해되는 원격 프로시저 호출 프로토콜인 &lt;strong&gt;JSON-RPC 2.0&lt;/strong&gt;을 기반으로 구축되었습니다. MCP는 다양한 배포 시나리오를 지원하기 위해 전송 계층을 유연하게 설계했으며, 그 발전 과정은 프로토콜의 적용 범위 확대를 명확히 보여줍니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;STDIO (Standard Input/Output):&lt;/strong&gt; 가장 초기의 단순한 전송 방식으로, 클라이언트와 서버가 동일한 환경에서 실행되는 &lt;span style="background:#fff88f"&gt;로컬 프로세스 통합에 이상적&lt;/span&gt;입니다. 예를 들어, IDE(호스트)가 로컬 파일 시스템에 접근하는 서버와 통신하는 경우에 사용됩니다. STDIO의 가장 큰 강점은 기존의 원격 전용 API(예: REST)가 쉽게 복제할 수 없는 로컬 우선(local-first) 에이전트 워크플로우를 가능하게 한다는 점입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HTTP와 서버-전송 이벤트 (SSE):&lt;/strong&gt; 원격 연결을 위해 처음 도입된 메커니즘으로, 서버가 클라이언트에게 비동기적으로 알림을 푸시할 수 있게 했습니다. 하지만 SSE는 장시간 연결을 유지해야 하는 특성 때문에 기업 방화벽에 의해 차단되거나, AWS Lambda와 같은 상태 비저장(stateless) 클라우드 함수 환경에서는 사용하기 어렵고, 역압력(back-pressure) 처리가 &lt;u&gt;까다로운 문제점&lt;/u&gt;을 드러냈습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;스트리밍 가능한 HTTP (Streamable HTTP):&lt;/strong&gt; 2025년 3월 업데이트에서 도입된 현재의 표준 원격 통신 방식입니다. 이 방식은 청크 분할 전송 인코딩(chunked transfer encoding)을 지원하는 단&lt;u&gt;일 HTTP 요청을 통해 양방향 바이트 스트림을 터널링&lt;/u&gt;합니다. 이 방식을 통해 MCP 서버를 &lt;span style="background:#fff88f"&gt;상태 비저장 클라우드 함수로 배포&lt;/span&gt;할 수 있게 되었고, 일반적인 &lt;span style="background:#fff88f"&gt;기업 네트워크 프록시 문제를 우회&lt;/span&gt;할 수 있어, MCP가 프로덕션 등급의 클라우드 네이티브 애플리케이션에 적용될 수 있는 길을 열었습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WebSocket:&lt;/strong&gt; 최대의 상호작용성이 요구되는 시나리오를 위한 전송 방식으로 언급되며, 완전한 양방향(full-duplex) 통신을 제공합니다. 이는 스트리밍 데이터, 진행 상황 업데이트, 협업 상호작용 등이 포함된 복잡한 AI 워크플로우에 특히 유용할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;전송 방식&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;주요 사용 사례&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;통신 모델&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;지연 시간&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;확장성&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;네트워크 호환성&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;현재 상태&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;STDIO&lt;/td&gt;
&lt;td&gt;로컬 프로세스 간 통신 (예: 데스크톱 앱)&lt;/td&gt;
&lt;td&gt;양방향&lt;/td&gt;
&lt;td&gt;매우 낮음&lt;/td&gt;
&lt;td&gt;제한적 (단일 머신)&lt;/td&gt;
&lt;td&gt;해당 없음 (로컬)&lt;/td&gt;
&lt;td&gt;활성&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HTTP + SSE&lt;/td&gt;
&lt;td&gt;초기 원격 연결&lt;/td&gt;
&lt;td&gt;단방향 (서버→클라이언트)&lt;/td&gt;
&lt;td&gt;낮음-중간&lt;/td&gt;
&lt;td&gt;중간&lt;/td&gt;
&lt;td&gt;표준 HTTP/S 포트&lt;/td&gt;
&lt;td&gt;사용되지 않음 (Deprecated)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Streamable HTTP&lt;/td&gt;
&lt;td&gt;원격/클라우드 배포&lt;/td&gt;
&lt;td&gt;양방향 (단일 연결)&lt;/td&gt;
&lt;td&gt;낮음-중간&lt;/td&gt;
&lt;td&gt;높음&lt;/td&gt;
&lt;td&gt;표준 HTTP/S 포트&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;현재 표준&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WebSocket&lt;/td&gt;
&lt;td&gt;고도의 실시간 상호작용&lt;/td&gt;
&lt;td&gt;완전 양방향 (Full-duplex)&lt;/td&gt;
&lt;td&gt;매우 낮음&lt;/td&gt;
&lt;td&gt;높음&lt;/td&gt;
&lt;td&gt;별도 프로토콜/포트 필요 가능&lt;/td&gt;
&lt;td&gt;고려 대상&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="데이터-교환"&gt;데이터 교환
&lt;/h3&gt;&lt;p&gt;단순한 함수 호출 API는 모든 외부 상호작용을 &amp;ldquo;이것을 하라&amp;quot;는 명령으로 취급합니다. 이는 맥락에 대한 일차원적인 시각입니다.&lt;/p&gt;
&lt;p&gt;MCP는 맥락을 전달하기 위해 기능보다 더 세분화된 표현 단위인 프리미티브를 사용합니다. 이는 &lt;u&gt;기능 목록이 아니라&lt;/u&gt;, &lt;span style="background:#fff88f"&gt;AI와 시스템 간의 통신을 위한 구조화된 문법&lt;/span&gt;입니다. 이는 맥락 뿐만 아니라 &lt;u&gt;맥락의 의도를 전달하는 것이 중요&lt;/u&gt;하다는 철학을 아키텍처적으로 구현한 것입니다.&lt;/p&gt;
&lt;h4 id="서버의-프리미티브"&gt;서버의 프리미티브
&lt;/h4&gt;&lt;p&gt;핵심은 세 가지 프리미티브를 통한 표준화된 상호작용입니다: &lt;strong&gt;Tools(실행 가능한 함수)&lt;/strong&gt;, &lt;strong&gt;Resources(구조화된 읽기 전용 데이터)&lt;/strong&gt;, 그리고 &lt;strong&gt;Prompt Templates(사전 정의된 지침)&lt;/strong&gt;. 일반적으로 도구는 모델이 제어하고, 리소스와 프롬프트는 사용자가 제어합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;도구 (Tools):&lt;/strong&gt; &lt;u&gt;API를 호출하거나, 데이터베이스에 쿼리를 보내거나, 계산을 수행&lt;/u&gt;하는 등 &lt;span style="background:#fff88f"&gt;행동을 수행&lt;/span&gt;하고 &lt;u&gt;부수 효과(side effect)&lt;/u&gt;를 가질 수 있는 실행 가능한 함수입니다. 이는 &lt;strong&gt;행동하려는 의도(intent to act)&lt;/strong&gt; 를 나타냅니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;리소스 (Resources):&lt;/strong&gt; &lt;u&gt;파일의 내용, API 응답 결과, 데이터베이스 레코드&lt;/u&gt; 등 같이 모델의 컨텍스트를 풍부하게 하기 위해 제공되는 구조화된 &lt;span style="background:#fff88f"&gt;읽기 전용 데이터&lt;/span&gt;입니다. 이는 &lt;strong&gt;정보를 제공하려는 의도(intent to inform)&lt;/strong&gt; 를 나타냅니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;프롬프트 (Prompts):&lt;/strong&gt; 특정 작업을 위해 &lt;span style="background:#fff88f"&gt;모델의 추론을 안내&lt;/span&gt;할 수 있는 재사용 가능한 사전 정의된 지침 템플릿입니다. 이는 &lt;strong&gt;안내하려는 의도(intent to guide)&lt;/strong&gt; 를 나타냅니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 의도 분리로 더 정교한 시스템 설계가 가능합니다. 예를 들어, 보안에 민감한 애플리케이션은 에이전트에게 민감한 데이터베이스의 &lt;code&gt;Resources&lt;/code&gt;(읽기 전용 데이터)에 대한 접근은 허용하되, 데이터를 수정할 수 있는 &lt;code&gt;Tools&lt;/code&gt;(행동)에 대한 접근은 거부할 수 있습니다. 단순한 함수 호출 인터페이스는 이를 명확하게 표현하기 어렵습니다. 이 문법은 시스템이 AI에게 &amp;ldquo;여기 읽을 데이터가 있다&amp;rdquo;, &amp;ldquo;여기 네가 취할 수 있는 행동이 있다&amp;rdquo;, &amp;ldquo;이 문제는 이렇게 접근해야 한다&amp;quot;와 같이 미묘한 지시를 전달하여, LLM과 보다 정교하게 통신합니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;프리미티브&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;철학적 의도&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;기술적 기능&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;사용 사례 예시&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;도구 (Tool)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;행동하기 (To Act)&lt;/td&gt;
&lt;td&gt;부수 효과가 있는 실행 가능한 함수&lt;/td&gt;
&lt;td&gt;&lt;code&gt;post_message_to_slack&lt;/code&gt;, &lt;code&gt;create_calendar_event&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;리소스 (Resource)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;정보 제공하기 (To Inform)&lt;/td&gt;
&lt;td&gt;구조화된 읽기 전용 데이터&lt;/td&gt;
&lt;td&gt;재무 보고서 PDF, 데이터베이스 스키마, 사용자 프로필&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;프롬프트 (Prompt)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;안내하기 (To Guide)&lt;/td&gt;
&lt;td&gt;재사용 가능한 지침 템플릿&lt;/td&gt;
&lt;td&gt;법률 문서 요약 템플릿, 코드 리팩토링 지침&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="클라이언트의-프리미티브"&gt;클라이언트의 프리미티브
&lt;/h4&gt;&lt;p&gt;서버보단 사용 빈도가 낮지만, 클라이언트도 프리미티브를 가집니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;루트 (Roots):&lt;/strong&gt; 서버가 허가를 받아 접근할 수 있는 호스트의 로컬 환경(예: 파일 시스템 디렉토리)에 대한 진입점입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;샘플링 (Sampling):&lt;/strong&gt; 서버가 &lt;span style="background:#fff88f"&gt;클라이언트의 LLM에게 추론 작업(예: 텍스트 생성, 콘텐츠 요약)을 수행하고 그 결과를 반환하도록 요청&lt;/span&gt;할 수 있습니다. 서버는 모델, 시스템 프롬프트, temperature와 같은 매개변수를 지정할 수 있습니다. Python SDK는 이를 위해 &lt;code&gt;ctx.session.create_message&lt;/code&gt; 메서드를 제공합니다. 이 기능은 전문화된 도구가 범용 추론이나 창의적 능력을 가진 호스트 LLM을 활용할 수 있게 하여, 도구가 다른 도구를 사용하는 것과 같은 구성 가능한 시스템을 만듭니다. 여기서 LLM은 일종의 &amp;ldquo;추론 도구&amp;rdquo; 역할을 하게 됩니다. 샘플링을 사용하면 MCP 서버는 &lt;u&gt;자체적으로 무거운 LLM을 내장하거나 특정 모델에 종속될 필요 없이&lt;/u&gt;, 모델 독립적인 도구를 만들 수 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;채록 (Elicitation):&lt;/strong&gt; 서버가 워크플로우를 일시 중지하고, 클라이언트를 통해 최종 &lt;span style="background:#fff88f"&gt;사용자에게 추가적인 구조화된 정보를 요청&lt;/span&gt;할 수 있습니다. 서버는 필요한 입력에 대한 스키마를 정의합니다. Python SDK 예제에서는 &lt;code&gt;book_table&lt;/code&gt; 도구가 특정 날짜에 예약이 불가능할 경우 &lt;code&gt;ctx.elicit&lt;/code&gt;을 사용하여 사용자에게 대체 날짜를 묻는 것을 보여줍니다. 이 기능은 에이전트가 중요한 결정 지점에서 사용자에게 명확한 설명이나 승인을 요청할 수 있는 &lt;u&gt;&amp;ldquo;인간 참여형(human-in-the-loop)&amp;rdquo; 워크플로우를 구현&lt;/u&gt;하는 공식적인 메커니즘입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="활용"&gt;활용
&lt;/h4&gt;&lt;p&gt;MCP의 핵심 원칙 중 하나는 &lt;strong&gt;구조화된 컨텍스트&lt;/strong&gt;의 사용입니다. &lt;u&gt;기존 REST API의 응답을 그대로 LLM의 컨텍스트 창에 주입하면, 불필요한 정보로 인해 토큰이 낭비되고 모델의 추론 능력이 저하&lt;/u&gt;될 수 있습니다. MCP는 &lt;strong&gt;구조화된 도구 출력(Tool Output Schema)&lt;/strong&gt; 과 같은 기능을 통해 이 문제를 해결합니다. 서버는 반환할 데이터의 형태를 미리 선언하고, LLM에게는 작업과 관련된 간결하고 구조화된 객체만 전달하여 토큰 효율성을 높이고 모델이 정보를 더 효과적으로 파싱하도록 돕습니다.&lt;/p&gt;
&lt;p&gt;또한 정적인 데이터 교환을 넘어 &lt;strong&gt;동적 컨텍스트&lt;/strong&gt; 처리를 지원합니다. &lt;strong&gt;구독 가능한 리소스(Subscribable Resources)&lt;/strong&gt; 는 기반 &lt;u&gt;데이터가 변경될 때마다 클라이언트에게 알림을 보내 재처리를 유발&lt;/u&gt;할 수 있으며, &lt;strong&gt;샘플링된 리소스(Sampled Resources)&lt;/strong&gt; 는 &lt;u&gt;대규모 데이터 소스에서 요약 정보를 추출하는 데 사용&lt;/u&gt;될 수 있습니다. 특히 &lt;strong&gt;샘플링(Sampling)&lt;/strong&gt; 기능은 서버가 클라이언트 측의 LLM에게 특정 프롬프트에 대한 응답 생성을 요청할 수 있게 하여, 단순한 요청-응답 패턴을 넘어서는 진정한 의미의 양방향 대화를 가능하게 합니다. 이는 MCP를 다른 프로토콜과 차별화하는 핵심적인 특징입니다.&lt;/p&gt;
&lt;h2 id="다른-기술과의-관계"&gt;다른 기술과의 관계
&lt;/h2&gt;&lt;p&gt;MCP는 기존 기술 스택을 완전히 대체하기보다는 &lt;span style="background:#fff88f"&gt;보완하고 확장하는 역할&lt;/span&gt;에 가깝습니다. 다른 기술과 비교하여, 그 독자적인 가치와 기술 생태계 내에서의 전략적 위치를 명확히 규명합니다.&lt;/p&gt;
&lt;h3 id="restgraphql-상태-발견-컨텍스트의-패러다임-전환"&gt;REST/GraphQL: 상태, 발견, 컨텍스트의 패러다임 전환
&lt;/h3&gt;&lt;p&gt;MCP와 REST/GraphQL 같은 전통적 API는 근본적으로 다른 목적을 위해 설계되었습니다. 이 둘의 차이는 상태 관리, 서비스 발견, 그리고 컨텍스트 처리 방식에서 패러다임의 전환을 보여줍니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;목적의 차이:&lt;/strong&gt; 전통적인 API는 주로 &lt;u&gt;애플리케이션 간의 통신&lt;/u&gt;을 위해 설계되었으며, 애플리케이션이 처리할 구조화된 &lt;strong&gt;데이터(data)&lt;/strong&gt; 를 반환합니다. 반면, MCP는 AI, 특히 LLM을 위해 제작되었습니다. MCP 서버는 LLM이 추론하는 데 필요한 &lt;strong&gt;컨텍스트(context)&lt;/strong&gt; 를 제공하는 것을 목표로 합니다. 예를 들어, REST API가 10KB 크기의 방대한 JSON 객체를 반환한다면, 잘 설계된 MCP 서버는 LLM의 컨텍스트 창에 최적화된 간결하고 작업 관련성이 높은 &lt;span style="background:#fff88f"&gt;요약 정보를 제공&lt;/span&gt;할 것입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;발견(Discovery) 방식:&lt;/strong&gt; REST나 GraphQL API는 정적입니다. 개발자는 OpenAPI 명세서와 같은 문서를 사전에 읽고 학습해야만 해당 API를 사용할 수 있습니다. 이와 대조적으로, MCP는 동적인 런타임 발견을 지원합니다. MCP 클라이언트는 서버에 &lt;code&gt;tools/list&lt;/code&gt;와 같은 요청을 보내 사전 지식 없이도 해당 &lt;u&gt;서버가 제공하는 기능 목록과 사용법을 실시간으로 파악&lt;/u&gt;할 수 있습니다. 이는 AI 에이전트가 보다 자율적이고 적응적으로 동작할 수 있게 하는 핵심 기능입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;통신 패턴:&lt;/strong&gt; REST는 각 요청이 독립적으로 처리되는 상태 비저장(stateless) 방식입니다. MCP는 &lt;u&gt;세션 기반의 양방향(bidirectional) 통신 모델&lt;/u&gt;을 채택하여 여러 상호작용에 걸쳐 &lt;span style="background:#fff88f"&gt;컨텍스트를 유지&lt;/span&gt;합니다. 이는 여러 단계로 구성된 복잡한 에이전트 워크플로우를 수행하는 데 필수적입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상호 관계:&lt;/strong&gt; MCP는 REST를 대체하는 기술이 아니라는 것입니다. 오히려 MCP는 기존 API 위에 구축되는 &lt;strong&gt;보완적인 추상화 계층&lt;/strong&gt;입니다. 실제로 많은 MCP 서버는 기존 &lt;span style="background:#fff88f"&gt;REST API를 AI 친화적으로 감싸는 래퍼(wrapper) 역할&lt;/span&gt;을 합니다. 예를 들어, GitHub MCP 서버는 내부적으로 &lt;u&gt;GitHub의 REST API를 호출하여 MCP의 표준화된 형식으로 변환한 후 클라이언트에게 제공&lt;/u&gt;합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;특징/원칙&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;모델 컨텍스트 프로토콜 (MCP)&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;전통적인 REST API&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;표준화&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;개방형, 범용 표준&lt;/td&gt;
&lt;td&gt;표준 부재 (각 API가 고유)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;발견 메커니즘&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;동적, 런타임에 질의 가능&lt;/td&gt;
&lt;td&gt;정적, 문서를 통해 파악&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;주요 목적&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;AI 모델과 외부 시스템 간의 맥락 교환&lt;/td&gt;
&lt;td&gt;범용 소프트웨어 간 통신&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;생태계 모델&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;개방형, 커뮤니티 주도, 상호 운용 가능&lt;/td&gt;
&lt;td&gt;단편화된, 개별적 통합&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;맥락의 풍부함&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;도구, 리소스, 프롬프트를 통한 의도 전달&lt;/td&gt;
&lt;td&gt;주로 데이터 검색/조작에 초점&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="grpc-성능-스키마-그리고-llm-친화성에-대한-고찰"&gt;gRPC: 성능, 스키마, 그리고 LLM 친화성에 대한 고찰
&lt;/h3&gt;&lt;p&gt;gRPC는 고성능 마이크로서비스 통신을 위해 설계된 반면, MCP는 LLM과의 상호작용에 최적화되어 있습니다. 이 둘의 비교는 성능과 LLM 해석 가능성 사이의 중요한 트레이드오프를 보여줍니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;성능 vs. 해석 가능성:&lt;/strong&gt; gRPC는 고효율의 바이너리 직렬화 포맷인 프로토콜 버퍼(Protocol Buffers)와 HTTP/2를 사용하여 &lt;u&gt;기계 간 통신 성능을 극대화&lt;/u&gt;합니다. 반면 MCP는 &lt;span style="background:#fff88f"&gt;LLM의 해석 가능성을 우선시&lt;/span&gt;합니다. 이를 위해 사람이 쉽게 읽고 이해할 수 있는 JSON 형식을 사용하며, 스키마 내에 자연어 설명과 사용 지침을 포함시킵니다. 이 덕분에 LLM은 별도의 변환 계층 없이도 도구의 목적과 매개변수를 훨씬 쉽게 이해할 수 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;스키마 및 계약:&lt;/strong&gt; 두 기술 모두 강력한 타입의 스키마를 사용합니다. gRPC는 프로토콜 버퍼를 통해 엄격한 서비스 계약을 정의합니다. MCP 역시 JSON-RPC 2.0 기반의 정의된 스키마를 사용하지만, 여기에 &lt;span style="background:#fff88f"&gt;자연어 프롬프트와 설명이라는 추가적인 의미 계층&lt;/span&gt;을 더합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="openai-함수-호출-인프라와-의도의-상호보완적-관계"&gt;OpenAI 함수 호출: &amp;lsquo;인프라&amp;rsquo;와 &amp;lsquo;의도&amp;rsquo;의 상호보완적 관계
&lt;/h3&gt;&lt;p&gt;MCP와 OpenAI의 함수 호출(Function Calling)은 경쟁 관계가 아니라, 서로 다른 역할을 수행하는 상호보완적인 관계입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;핵심적인 차이:&lt;/strong&gt; 함수 호출은 &lt;strong&gt;&amp;lsquo;의도(intent)&amp;rsquo;&lt;/strong&gt; 에 해당합니다. LLM이 &lt;u&gt;특정 작업을 수행해야 할 필요성을 인식&lt;/u&gt;하고, 필요한 매개변수를 구조화된 형식으로 출력하는 메커니즘입니다. 반면, MCP는 &lt;strong&gt;&amp;lsquo;인프라(infrastructure)&amp;rsquo;&lt;/strong&gt; 입니다. MCP는 LLM이 표현한 의도를 받아, 실제 작업을 &lt;span style="background:#fff88f"&gt;발견하고, 실행하며, 관리하&lt;/span&gt;는 표준화된 프로토콜입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;표준화 문제:&lt;/strong&gt; &lt;u&gt;함수 호출의 형식은 각 LLM 제공사(OpenAI, Anthropic, Google 등)마다 다릅니다.&lt;/u&gt; MCP를 사용하면 각 도구는 단 하나의 MCP 서버만 구현하면 되고, MCP와 호환되는 모든 모델이 이를 사용할 수 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;아키텍처:&lt;/strong&gt; 함수 호출에 사용되는 도구는 일반적으로 단일 애플리케이션 내에 하드코딩되어 정의됩니다. MCP는 도구가 그것을 소비하는 애플리케이션과 분리된, &lt;u&gt;재사용 가능한 별도의 서버에 존재하는 분산 아키텍처&lt;/u&gt;를 장려합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시너지:&lt;/strong&gt; 이 둘은 함께 작동합니다. LLM은 자신의 고유한 함수 호출 기능을 사용하여 요청을 생성합니다. 그러면 MCP 클라이언트가 이 요청을 받아 표준화된 프로토콜을 통해 적절한 MCP 서버로 전송하여 실행합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 비교 분석을 통해 MCP의 핵심 가치 제안이 특정 기술적 축에서의 우월성이 아니라, &lt;strong&gt;표준화를 통한 통합 마찰의 감소&lt;/strong&gt;에 있음을 알 수 있습니다. gRPC보다 빠르거나 단일 REST 호출보다 단순하지는 않지만, M×N 문제를 해결함으로써 전체 생태계의 &lt;span style="background:#fff88f"&gt;개발 효율성을 향상&lt;/span&gt;시킵니다. MCP는 기존 기술 스택을 대체하는 것이 아니라, 그 위에 새로운 가치를 창출하는 &lt;span style="background:#fff88f"&gt;추상화 계층&lt;/span&gt;으로 위치합니다. 이는 MCP와 기존 기술 사이에서 양자택일할 필요 없이, MCP를 새로운 계층으로 활용하여 시스템을 강화하는 전략을 고려해야 함을 의미합니다.&lt;/p&gt;
&lt;h2 id="mcp의-방향"&gt;MCP의 방향
&lt;/h2&gt;&lt;h3 id="변경-사항"&gt;변경 사항
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;초기 안정화 (2024-11-05):&lt;/strong&gt; 최초 공개된 버전은 MCP의 핵심 개념을 정립하는 데 중점을 두었습니다. JSON-RPC 2.0 기반의 메시지 형식과 함께, 프로토콜의 핵심 프리미티브(primitive)인 &lt;code&gt;tool&lt;/code&gt;(도구), &lt;code&gt;resource&lt;/code&gt;(리소스), &lt;code&gt;prompt&lt;/code&gt;(프롬프트)가 정의되었습니다. 이 시점에서는 스트리밍 통신을 위한 전송 방식으로 HTTP와 서버-전송 이벤트(Server-Sent Events, SSE)를 채택했는데, 이는 실시간 대화형 사용 사례에 초기 초점을 맞추었음을 시사합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;엔터프라이즈 및 보안 강화 (2025-03-26):&lt;/strong&gt; 이 버전은 MCP가 본격적으로 엔터프라이즈 시장을 겨냥하기 시작했음을 알리는 중요한 전환점입니다. 가장 주목할 만한 변화는 &lt;span style="background:#fff88f"&gt;OAuth 2.1 기반의 포괄적인 인증 프레임워크 도입&lt;/span&gt;입니다.1 이는 기업 환경에서 필수적인 강력한 보안 및 신원 관리 요구사항을 충족시키기 위한 결정이었습니다. 또한, 기존 SSE 방식이 가진 기업 방화벽 및 프록시 환경에서의 호환성 문제를 해결하기 위해, 보다 유연하고 견고한 &lt;strong&gt;스트리밍 가능한 HTTP(Streamable HTTP)&lt;/strong&gt; 전송 방식으로 대체되었습니다. 더불어, 도구의 속성을 명시하는 &lt;code&gt;tool annotations&lt;/code&gt;(예: 읽기 전용, 파괴적 행위) 기능과 오디오 콘텐츠 지원이 추가되어, 더욱 풍부하고 제어된 상호작용이 가능해졌습니다. 성능 최적화를 위해 JSON-RPC 일괄 처리(batching) 기능이 잠시 도입되었다가 이후 버전에서 철회되었는데, 이는 프로토콜의 효율성과 단순성 사이에서 균형점을 찾으려는 시도가 있었음을 보여줍니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;정제 및 보안 강화 (2025-06-18):&lt;/strong&gt; 가장 최신 릴리스는 프로토콜의 완성도를 높이고 보안을 한층 더 강화하는 데 집중했습니다. 일괄 처리 기능을 제거하여 프로토콜의 복잡성을 낮추고 구현을 단순화했습니다. 핵심적인 추가 사항은 예측 가능한 통합을 위한 구조화된 도구 출력(structured tool output)과, MCP 서버를 OAuth 리소스 서버로 분류하고 토큰 오용을 방지하기 위해 리소스 표시자(Resource Indicators, RFC 8707) 사용을 의무화한 것입니다. 이는 &amp;lsquo;혼란된 대리인(confused deputy)&amp;rsquo; 문제와 같은 실제적인 보안 위협에 대한 깊은 이해를 바탕으로 한 조치입니다. 또한, 서버가 사용자에게 요청을 시작할 수 있는 유도(elicitation) 기능이 추가되어 프로토콜의 양방향 상호작용성이 더욱 강화되었습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 프로토콜의 발전 과정은 우연이 아닙니다. 초기에는 개발자 커뮤니티의 지지를 확보하는 데 주력하고, 이후에는 기업 고객의 엄격한 보안 및 운영 요구사항을 충족시키는 방향으로 명확하게 전환하는 전략적 움직임을 보여줍니다. 이는 MCP가 단기적인 유행이 아닌, 장기적으로 지속 가능한 표준으로 자리매김하려는 의도를 명백히 드러냅니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;버전 (릴리스 날짜)&lt;/th&gt;
&lt;th&gt;주요 기능 및 향상점&lt;/th&gt;
&lt;th&gt;주요 변경 사항 (Breaking Changes)&lt;/th&gt;
&lt;th&gt;전략적 중요성&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;2024-11-05&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;• 핵심 아키텍처 및 메시지 형식 정의 (JSON-RPC 2.0) • &lt;code&gt;tool&lt;/code&gt;, &lt;code&gt;resource&lt;/code&gt;, &lt;code&gt;prompt&lt;/code&gt; 프리미티브 도입 • HTTP + SSE 기반 스트리밍 전송&lt;/td&gt;
&lt;td&gt;해당 없음 (초기 버전)&lt;/td&gt;
&lt;td&gt;개발자 중심의 초기 생태계 구축 및 핵심 개념 정립. 대화형 AI 에이전트의 기본 기능 지원에 초점.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;2025-03-26&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;• OAuth 2.1 기반 인증 프레임워크 추가 • &lt;code&gt;tool annotations&lt;/code&gt; (읽기 전용, 파괴적 등) 도입 • 오디오 콘텐츠 지원 추가&lt;/td&gt;
&lt;td&gt;• SSE를 Streamable HTTP로 대체&lt;/td&gt;
&lt;td&gt;엔터프라이즈 도입의 핵심 장벽인 보안 및 네트워크 호환성 문제 해결. 프로토콜의 적용 범위를 기업 환경으로 확장.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;2025-06-18&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;• &lt;code&gt;structured tool output&lt;/code&gt; 지원 • MCP 서버를 OAuth 리소스 서버로 분류 • Resource Indicators (RFC 8707) 요구 • 서버 주도 요청을 위한 &lt;code&gt;elicitation&lt;/code&gt; 기능 추가&lt;/td&gt;
&lt;td&gt;• JSON-RPC 일괄 처리 기능 제거&lt;/td&gt;
&lt;td&gt;&amp;lsquo;혼란된 대리인&amp;rsquo; 등 정교한 보안 위협에 대응하여 프로토콜을 강화. 프로토콜의 단순성과 보안성을 동시에 향상.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="현재-보고된-문제점"&gt;현재 보고된 문제점
&lt;/h3&gt;&lt;p&gt;하지만 앞의 발전 외에도, 사용자들은 MCP에 대해 다음의 문제들을 보고하고 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;멀티테넌시(Multi-Tenancy):&lt;/strong&gt; 많은 사용자가 공유 서버에 안전하게 접근해야 하는 멀티테넌트 SaaS 아키텍처를 위해 설계되지 않았습니다. 이는 많은 엔터프라이즈 사용 사례에 주요한 장애물입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;디버깅 및 관찰 가능성:&lt;/strong&gt; 개발자들은 MCP 통합을 디버깅하는 것이 매우 어렵다고 보고합니다. 클라이언트 측 추적이 종종 누락되거나 접근하기 어렵고, 각 클라이언트마다 고유한 특성이 있기 때문입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;발견 및 신뢰:&lt;/strong&gt; 서버를 발견할 수는 있지만, 신뢰성을 검증할 중앙화된 &lt;u&gt;신뢰할 수 있는 레지스트리가 없습니다.&lt;/u&gt; 이는 에이전트가 신뢰할 수 없거나 악의적인 서버에 연결될 위험을 초래합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;워크플로우 오케스트레이션:&lt;/strong&gt; MCP에는 복잡한 다단계 워크플로우를 관리하기 위한 기능이 부족하여, 클라이언트의 &lt;u&gt;재시도나 재개 가능성과 같은 로직을 직접 구현&lt;/u&gt;해야 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;영역&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;구체적인 과제&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;잠재적 미래 방향 / 연구 분야&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;거버넌스&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;내장된 세분화된 권한 모델 없음&lt;/td&gt;
&lt;td&gt;사양에 권한 모델 도입, 제3자 PAM 솔루션과의 표준 통합&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;운영 확장성&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;멀티테넌시 지원 부족&lt;/td&gt;
&lt;td&gt;멀티테넌트 서버 아키텍처를 위한 패턴 정의&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;생태계 건전성&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;신뢰할 수 있는 서버 레지스트리 부재&lt;/td&gt;
&lt;td&gt;커뮤니티가 관리하는 검증된 레지스트리 구축&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;개발자 경험&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;디버깅 및 워크플로우 관리의 복잡성&lt;/td&gt;
&lt;td&gt;표준화된 디버깅 도구 및 워크플로우 오케스트레이션 프리미티브 도입&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;MCP에서는 이러한 문제점을 어떻게 개선하고, 향후 어떻게 나아갈 것인지 살펴보겠습니다.&lt;/p&gt;
&lt;h3 id="2025년-7월-공식-로드맵-분석-에이전트-보안-멀티모달리티"&gt;2025년 7월 공식 로드맵 분석: 에이전트, 보안, 멀티모달리티
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;에이전트 기능 강화:&lt;/strong&gt; 로드맵의 최우선 과제 중 하나는 &lt;u&gt;더 복잡한 에이전트 워크플로우를 지원&lt;/u&gt;하는 것입니다. 특히 수 분에서 수 시간에 이르는 작업을 처리할 수 있는 &lt;strong&gt;비동기 작업(asynchronous operations)&lt;/strong&gt; 지원이 핵심입니다. 이는 단순한 질의응답을 넘어 장기적인 목표를 수행하는 자율 에이전트 구현에 필수적인 기능입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인증 및 보안 고도화:&lt;/strong&gt; 엔터프라이즈 도입을 위해 보안은 여전히 가장 중요한 영역입니다. 로드맵에는 &lt;strong&gt;세분화된 권한 부여(fine-grained authorization)&lt;/strong&gt;, 사용자 경험을 해치지 않으면서 보안을 강화하기 위한 동적 클라이언트 등록(DCR)의 대안 탐색, 그리고 SSO(Single Sign-On)를 통한 &lt;strong&gt;엔터프라이즈 관리형 인증(enterprise-managed authorization)&lt;/strong&gt; 기능 추가 계획이 포함되어 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;검증 및 레지스트리:&lt;/strong&gt; 생태계의 신뢰성과 확장성을 위해, 일관된 구현을 보장하는 &lt;strong&gt;준수 테스트 스위트(compliance test suites)&lt;/strong&gt; 와 중앙에서 서버를 발견할 수 있는 &lt;strong&gt;MCP 레지스트리(MCP Registry)&lt;/strong&gt; 개발이 계획되어 있습니다. 특히 레지스트리는 앤스로픽이 직접 운영하는 앱스토어 형태가 아니라, 서드파티 마켓플레이스가 그 위에 구축될 수 있는 API 계층으로 구상되고 있어 개방형 생태계를 지향함을 보여줍니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;멀티모달리티 확장:&lt;/strong&gt; 현재의 텍스트와 이미지를 넘어, &lt;strong&gt;비디오&lt;/strong&gt;와 같은 추가적인 데이터 양식(modality)을 지원하고, 대화형 경험을 위한 &lt;strong&gt;스트리밍&lt;/strong&gt; 기능을 개선하여 AI의 전체 스펙트럼을 지원하는 것을 목표로 하고 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="커뮤니티-논의와-기술적-과제-a2a-grpc-통합-게이트웨이의-필요성"&gt;커뮤니티 논의와 기술적 과제: A2A, gRPC 통합, 게이트웨이의 필요성
&lt;/h3&gt;&lt;p&gt;공식 로드맵 외에도, 커뮤니티에서는 MCP의 미래를 형성할 중요한 기술적 논의가 활발하게 이루어지고 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MCP와 A2A (Agent-to-Agent Protocol):&lt;/strong&gt; 커뮤니티의 핵심 논의 중 하나는 MCP와 구글의 A2A 프로토콜 간의 관계입니다. 현재 지배적인 견해는 이 &lt;span style="background:#fff88f"&gt;둘이 경쟁 관계가 아닌 상호 보완적&lt;/span&gt;이라는 것입니다. MCP가 &lt;strong&gt;에이전트와 도구(agent-to-tool)&lt;/strong&gt; 간의 통신을 표준화하는 반면, A2A는 &lt;strong&gt;에이전트와 에이전트(agent-to-agent)&lt;/strong&gt; 간의 협업을 표준화하는 것을 목표로 합니다. 미래에는 A2A 프로토콜 기반의 에이전트가 자신의 도구를 사용하기 위해 내부적으로 MCP를 활용하는 구조가 될 수 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gRPC 통합 가능성:&lt;/strong&gt; 커뮤니티에서는 기존의 JSON/HTTP 전송 방식 대신, gRPC의 높은 성능과 성숙한 생태계를 활용하자는 주장이 꾸준히 제기되고 있습니다. 이는 MCP가 향후 다양한 전송 계층을 지원하는 방향으로 발전할 수 있음을 시사합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;게이트웨이의 필연성:&lt;/strong&gt; 프로덕션 환경, 특히 &lt;u&gt;다중 테넌트나 기업 환경에서 보안, 관찰 가능성, 트래픽 관리를 위한 게이트웨이 계층의 필요성&lt;/u&gt;은 전문가들 사이에서 거의 공통된 의견입니다. 게이트웨이는 MCP 핵심 명세에 포함되어 있지는 않지만, 사실상 안전한 배포를 위한 &lt;span style="background:#fff88f"&gt;필수 구성 요소&lt;/span&gt;로 인식되고 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="mcp-생태계의-확장-주요-플레이어-시장-그리고-인프라"&gt;MCP 생태계의 확장: 주요 플레이어, 시장, 그리고 인프라
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;주요 플레이어의 참여:&lt;/strong&gt; MCP의 가장 큰 성공 요인 중 하나는 주요 기업들의 지지입니다. Anthropic이 시작했지만, &lt;span style="background:#fff88f"&gt;경쟁사인 OpenAI, Google DeepMind, Microsoft가 이를 채택&lt;/span&gt;했습니다. Microsoft는 Copilot Studio에 MCP를 통합하고 C# SDK를 공동으로 유지 관리하고 있으며 , GitHub는 VS Code 내 MCP 지원을 정식 버전으로 출시했습니다. 이러한 &amp;lsquo;경쟁적 협력(coopetition)&amp;rsquo; 구도는 MCP가 단일 벤더에 종속되지 않는 사실상의 업계 표준으로 자리 잡을 가능성을 높여줍니다. 이는 특정 기업의 향방과 관계 없이 프로토콜의 장기적 안정성을 보장하므로, 다른 기업들의 채택 리스크를 크게 낮추는 효과가 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SDK 및 서버 생태계:&lt;/strong&gt; TypeScript, Python, Java, C#, Go, Rust, Ruby 등 주요 언어에 대한 공식 SDK가 제공되고 있으며, 이는 종종 Microsoft(C#), Google(Go)과 같은 파트너사와의 협력을 통해 개발됩니다. GitHub, Slack, 데이터베이스, Puppeteer 등 널리 사용되는 도구들을 위한 오픈소스 서버 저장소도 방대하게 구축되어 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;신흥 마켓플레이스와 인프라:&lt;/strong&gt; MCP를 중심으로 한 상업 생태계도 형성되고 있습니다. mcpmarket.com과 같이 사전 구축된 서버를 발견하고 사용할 수 있는 마켓플레이스와, MCP 서버의 구축 및 호스팅을 단순화하는 인프라 도구들이 등장하고 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="장기적-비전-자율-에이전트와-ai-네이티브-웹의-기반으로서의-mcp"&gt;장기적 비전: 자율 에이전트와 AI 네이티브 웹의 기반으로서의 MCP
&lt;/h3&gt;&lt;p&gt;MCP에 대한 장기적인 비전은 단순한 도구 통합을 훨씬 뛰어넘습니다. 이는 차세대 컴퓨팅을 위한 기반 프로토콜로 자리매김하는 것입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;자율 시스템의 기반:&lt;/strong&gt; MCP는 인간의 직접적인 개입 없이 기업의 리소스나 웹 서비스를 동적으로 발견하고, 학습하며, 상호작용할 수 있는 자율 에이전트 시스템에 필요한 핵심 패턴을 제공합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;에이전트 상거래와 AI 네이티브 웹:&lt;/strong&gt; 전문가들은 MCP가 &lt;strong&gt;&amp;lsquo;AI 네이티브 웹(AI-Native Web)&amp;rsquo;&lt;/strong&gt; 을 가능하게 할 것이라고 전망합니다. 과거 HTTP와 웹 브라우저가 인간이 웹 페이지와 상호작용하는 방식을 정의했다면, 미래에는 MCP가 AI 에이전트가 우리를 대신하여 웹에서 행동하는 방식을 정의할 수 있습니다. 이는 AI가 여러 서비스를 오가며 복잡한 구매 절차를 완료하는 &amp;lsquo;에이전트 상거래(agentic commerce)&amp;lsquo;와 같은 새로운 개념으로 이어질 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MCP의 궁극적인 영향은 단순히 기존 시스템을 AI에 연결하는 것을 넘어, 처음부터 &lt;strong&gt;&amp;lsquo;AI가 이해할 수 있는(AI-comprehensible)&amp;rsquo;&lt;/strong&gt; 시스템의 설계를 촉진하는 것입니다. 현재 &lt;u&gt;대부분의 MCP 서버는 AI를 위해 설계되지 않은 기존 API의 래퍼&lt;/u&gt;에 불과합니다. 하지만 미래에는 애플리케이션과 서비스가 설계 단계부터 MCP 인터페이스를 기본으로 고려하게 될 수 있으며, 이는 자율 AI 에이전트와의 상호작용을 전제로 하는 애플리케이션 설계 철학의 근본적인 변화입니다.&lt;/p&gt;
&lt;h3 id="최종-목표-인지-운영-체제"&gt;최종 목표: 인지 운영 체제
&lt;/h3&gt;&lt;p&gt;MCP의 비전은 단순한 커넥터 이상으로 위치하는 것입니다. 이는 에이전트의 의도를 실행과 연결하는 &amp;ldquo;신경 계약 계층(neural contract layer)&amp;rdquo; 또는 &amp;ldquo;인지 운영 체제(cognitive OS)&amp;ldquo;로 표현합니다.&lt;/p&gt;
&lt;p&gt;여기서 MCP는 다중 에이전트 시스템 전반에서 컨텍스트, 목표, 제약 조건에 대한 공유된 이해를 강제합니다. 이는 &amp;ldquo;의미론적 기억 저장소(semantic memory keeper)&amp;rdquo; 역할을 하여, 에이전트가 원래 임무에 맞게 행동하도록 보장합니다. 이 패러다임은 동적 다중 에이전트 거버넌스, 버전화된 컨텍스트 계보를 가진 &amp;ldquo;에이전트 DNA&amp;rdquo;, 그리고 에이전트 추론 디버깅을 위한 인지적 컨텍스트 비교(cognitive context diffing)와 같은 목표를 통해, 무결성을 잃지 않으면서 지능을 확장합니다.&lt;/p&gt;
&lt;h2 id="마치며"&gt;마치며
&lt;/h2&gt;&lt;p&gt;MCP는 AI 개발의 초점을 &amp;ldquo;모델 중심&amp;rdquo;(더 나은 모델 구축)에서 &amp;ldquo;맥락 중심&amp;rdquo;(모델 주변 데이터 및 도구 생태계 엔지니어링)으로 이동시켰습니다. 모델이 상호작용하는 환경을 설계하여 AI 시스템의 능력을 향상시킬 수 있다는 새로운 관점을 제시합니다.&lt;/p&gt;
&lt;p&gt;목적을 달성하려면 모델 자체의 성능도 큰 영향을 주지만, 필요한 데이터를 적절하게 전달하거나 원하는 동작을 수행할 수 있는 도구 등 생태계가 갖춰져야 합니다. 이러한 환경을 구현할 표준이 있다면 생산성, 재사용성 등 개발 효율성에서 큰 이점을 얻을 수 있습니다. MCP를 Anthropic, OpenAI, Microsoft, Google DeepMind 등 주요 기업들이 수용했다는 점에서 MCP 기술 자체는 신뢰하고 사용할 수 있다고 생각합니다.&lt;/p&gt;
&lt;p&gt;이번 글을 위해 자료를 찾으면서, &amp;ldquo;대부분의 MCP 서버는 AI를 위해 설계되지 않은 기존 API의 래퍼&amp;quot;라 언급된 것처럼 저 또한 이전까지는 MCP를 단순 요청 응답 형태로 사용하고 있었습니다. 에이전트와 MCP 서버를 &amp;ldquo;대화형 상호작용 모델&amp;quot;로 사용하는 것이 MCP의 철학인 만큼, 저도 올바르게 사용할 수 있도록 더 자세히 알아보려 합니다. 앞으로의 포스트에서는 MCP의 보다 구체적인 내용과, 고려사항에 대해 다루겠습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;본 포스트는 Google Gemini의 응답을 기반으로 저의 의견을 반영하여 다시 작성했습니다.&lt;/p&gt;&lt;/blockquote&gt;</description></item></channel></rss>