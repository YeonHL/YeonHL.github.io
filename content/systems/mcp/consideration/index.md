---
title: MCP 사용 시 고려사항
description: MCP는 많은 이점을 가져오지만, 충분한 고민이 없으면 잘못된 결과를 가져올 수 있습니다.
date: 2025-08-14T19:03:00
lastmod: 2025-09-09
slug: consideration
comments: true
math: false
categories:
  - Systems
tags:
  - MCP
  - LLM
keywords:
  - MCP
  - Agents
  - LLM
---

## 개요

### 1.1 메시징의 근간, JSON-RPC 2.0 심층 분석

MCP는 모든 클라이언트-서버 통신의 기반으로 JSON-RPC 2.0을 채택했다. 이는 경량성, 명확한 사양, 그리고 무엇보다 다양한 프로그래밍 언어 환경에서의 상호운용성을 보장하는 전략적 선택이다. JSON-RPC는 사람이 읽기 쉬운 JSON 형식을 사용하므로 디버깅이 용이하며, 이미 널리 채택된 표준이기에 개발자들이 쉽게 접근할 수 있다.8 MCP는 이 표준 위에 세 가지 핵심 메시지 유형을 정의하여 통신을 구조화한다.

- **요청(Request):** 요청 메시지는 클라이언트가 서버의 특정 기능을 호출하기 위해 전송하는 통신의 시작점이다. 이 메시지는 `jsonrpc`, `method`, `params`, 그리고 고유한 `id` 필드를 포함한다.8 `method` 필드는 `tools/call`이나 `resources/list`와 같이 호출할 함수의 이름을 명시한다. 가장 중요한 것은 `id` 필드로, 모든 요청을 고유하게 식별하여 비동기적인 환경에서도 요청과 응답을 정확하게 연결하는 역할을 한다. 이 `id`의 존재는 MCP가 단순한 단방향 호출이 아닌, 상태를 추적하고 관리하는 상태 기반(stateful) 상호작용을 전제로 설계되었음을 보여주는 핵심적인 증거다.8
    
- **응답(Response):** 서버는 요청을 처리한 후, 반드시 해당 요청의 `id`를 포함하는 응답 메시지를 반환한다. 작업이 성공했을 경우 `result` 필드에 결과 데이터를 담아 보내고, 실패했을 경우에는 `error` 필드에 에러 코드와 메시지를 담아 보낸다.8 이 명확한 성공/실패 구조는 클라이언트가 견고한 오류 처리 로직을 구현할 수 있게 하며, 복잡한 워크플로우에서 각 단계의 성공 여부를 안정적으로 추적할 수 있는 기반을 제공한다.
    
- **알림(Notification):** 알림은 요청과 달리 `id` 필드가 없어 서버로부터의 응답을 요구하지 않는 단방향 메시지다.8 이는 서버가 자신의 상태 변화를 클라이언트에게 능동적으로 전파해야 할 때 사용된다. 예를 들어, 서버에 새로운 도구가 추가되거나 기존 도구가 제거되었을 때, 서버는 `notifications/tools/list_changed` 알림을 보내 클라이언트가 최신 도구 목록을 유지할 수 있도록 한다.9 이 메커니즘은 MCP 환경을 정적인 상태가 아닌, 동적으로 변화하고 반응하는 생태계로 만드는 핵심 요소로 작용한다.
    

### 1.2 전송 메커니즘: 시나리오 기반 비교 분석

MCP는 특정 전송 기술에 종속되지 않도록 설계(transport-agnostic)되어, 다양한 배포 시나리오와 요구사항에 유연하게 대응할 수 있다.11 프로토콜은 주로 두 가지 전송 방식을 표준으로 지원하며, 각각은 뚜렷한 장단점과 사용 사례를 가진다.

- **`stdio` (Standard Input/Output):** 이 방식은 MCP 서버가 호스트 애플리케이션(예: IDE, 데스크톱 앱)의 로컬 서브프로세스로 실행될 때 사용된다. 통신은 운영체제의 표준 입력(stdin)과 표준 출력(stdout) 스트림을 통해 이루어진다.3 가장 큰 장점은 네트워크 스택을 거치지 않아 <u>지연 시간이 마이크로초 단위로 극도로 낮고</u>, 운영체제 수준의 프로세스 격리를 통해 외부 네트워크로부터의 접근이 원천적으로 차단되어 <u>보안성이 매우 높다</u>는 점이다.11 이러한 특성 때문에 VS Code나 Claude Desktop과 같은 개발 도구에서 사용자의 로컬 파일 시스템에 접근하거나 로컬 스크립트를 실행하는 등 민감한 작업을 안전하고 신속하게 처리하는 데 최적화되어 있다.
    
- **`HTTP+SSE` (Server-Sent Events) 및 `Streamable HTTP`:** 이 방식은 원격 서버와의 통신을 위해 설계되었다. 클라이언트에서 서버로의 요청은 일반적인 HTTP POST 요청을 사용하고, 서버에서 클라이언트로의 지속적인 데이터 스트리밍은 Server-Sent Events(SSE)를 통해 이루어진다.3 SSE는 단방향(서버→클라이언트) 통신 채널을 오랫동안 유지하며 업데이트를 푸시하는 데 특화되어 있다. 이 방식은 기존 웹 인프라(프록시, 방화벽, 로드밸런서)와 완벽하게 호환되므로, Stripe, GitHub, Sentry 등 클라우드 기반의 원격 SaaS API를 MCP 서버로 연동하는 데 이상적이다.3 다만, 양방향 통신을 위해 요청(HTTP POST)과 응답 스트림(SSE)을 별도의 채널로 관리해야 하는 복잡성이 존재한다. 최신 MCP 사양에서는 이러한 복잡성을 줄이기 위해 단일 HTTP 연결 내에서 양방향 스트리밍을 지원하는 `Streamable HTTP`로의 통합을 추진하고 있다.
    

이처럼 이중화된 전송 메커니즘은 MCP가 '보안'을 중시하는 로컬 환경과 '확장성'을 중시하는 원격 클라우드 환경이라는 두 가지 핵심 가치를 동시에 추구하기 위한 의도적인 설계적 타협임을 보여준다. 개발자는 자신의 사용 사례에 맞춰 최적의 전송 방식을 선택할 수 있지만, 이는 동시에 MCP 클라이언트(호스트)가 두 가지 상이한 통신 모델을 모두 안정적으로 처리해야 하는 기술적 과제를 안게 됨을 의미한다.

**Table 1: MCP 전송 메커니즘 비교 분석**

| 특성             | `stdio` (Standard Input/Output)                                              | `HTTP+SSE` / `Streamable HTTP`                                     | `WebSockets` (대안)                          |
| -------------- | ---------------------------------------------------------------------------- | ------------------------------------------------------------------ | ------------------------------------------ |
| **통신 유형**      | 로컬, 양방향                                                                      | 원격, 단방향 스트림 (SSE) / 양방향 (Streamable HTTP)                          | 원격, 양방향                                    |
| **주요 장점**      | - 매우 낮은 지연 시간 - 네트워크 설정 불필요 - OS 수준의 높은 보안 (샌드박싱)                            | - 기존 웹 인프라와 호환 - 서버리스 환경 지원 - 실시간 결과 스트리밍 가능                       | - 진정한 실시간 양방향 통신 - 단일 연결 관리로 인한 단순성        |
| **주요 단점/고려사항** | - 원격 서버 연결 불가 - 호스트가 서버 프로세스 생명주기 관리 필요                                      | - 양방향 통신을 위한 채널 관리 복잡성 (HTTP+SSE) - 장기 연결을 위한 프록시/로드밸런서 설정 필요      | - 일부 기업 네트워크에서 제한될 수 있음 - 초기 핸드셰이크 오버헤드 존재 |
| **대표 사용 사례**   | - IDE 플러그인 (VS Code, Cursor) - 로컬 파일 시스템 접근 - 데스크톱 AI 어시스턴트 (Claude Desktop) | - 원격 API 연동 (Stripe, Sentry) - 클라우드 기반 데이터 소스 연결 - 웹 브라우저 기반 클라이언트 | - 고빈도 상호작용이 필요한 채팅 애플리케이션 - 실시간 협업 도구      |


### 1.3 상호작용 생명주기(Lifecycle)와 기능 협상(Capability Negotiation)

MCP 세션은 단순한 요청-응답의 나열이 아니라, 명확한 단계를 거치는 상태 기반 연결(stateful connection)이다.2 이 생명주기의 핵심은 '기능 협상' 과정으로, 클라이언트와 서버가 서로가 제공하고 지원하는 기능을 동적으로 확인하고 합의하는 절차다.

1. **초기화 (`initialize`):** 연결이 시작되면, 클라이언트는 먼저 `initialize` 요청을 서버에 보낸다. 이 요청에는 클라이언트가 지원하는 프로토콜 버전 정보와 함께, 클라이언트가 제공할 수 있는 기능(예: 서버로부터 LLM 추론 요청을 받을 수 있는 `sampling` 기능 지원 여부)에 대한 정보가 포함된다.8
    
2. **기능 협상 (Response to `initialize`):** `initialize` 요청을 받은 서버는 자신의 정보(이름, 버전 등)와 함께 자신이 제공할 수 있는 기능의 목록을 담아 응답한다. 예를 들어, 서버는 자신이 `tools`와 `resources` 프리미티브를 제공하는지, 그리고 도구 목록이 변경될 때 `listChanged` 알림을 보낼 수 있는지 여부를 `capabilities` 객체에 담아 클라이언트에 알린다.9 이 교환 과정을 통해 양측은 앞으로의 세션에서 어떤 종류의 상호작용이 가능한지에 대해 명시적으로 합의하게 된다.
    
3. **초기화 완료 (`initialized`):** 서버로부터 기능 목록을 성공적으로 수신한 클라이언트는 `initialized` 알림을 서버에 보내 협상 과정이 완료되었음을 알린다.8 이 시점부터 본격적인 상호작용이 시작될 수 있다.
    
4. **실행 및 종료:** 초기화가 완료되면, 클라이언트는 협상된 기능을 바탕으로 `tools/list`, `tools/call`과 같은 구체적인 메서드를 호출하여 작업을 수행한다.9 세션은 연결이 끊어지면 종료되며, 이 과정에서 **세션 지속성** 메커니즘이 데이터 유실을 방지하는 역할을 할 수 있다.14
    

이러한 생명주기와 협상 과정은 MCP가 LSP의 성공적인 아키텍처를 AI 에이전트 생태계에 맞게 전략적으로 진화시켰음을 보여준다. LSP가 IDE와 언어 서버 간의 상호작용을 표준화하여 생태계를 폭발적으로 성장시킨 것처럼, MCP는 JSON-RPC 기반의 유사한 구조를 통해 AI 애플리케이션과 외부 기능 간의 "N:M" 연결 문제를 해결하고자 한다.1 특히, LSP가 주로 사용자의 입력에 반응하는 '수동적(reactive)' 모델인 반면, MCP는 `Sampling`과 같은 기능을 통해 서버가 클라이언트의 LLM을 호출하는 '능동적(proactive)' 상호작용을 지원함으로써, 단순한 도구 연동을 넘어 자율적인 AI 에이전트 워크플로우를 지원하도록 한 단계 더 나아갔다.

## Section 2: 동적 컨텍스트 관리 및 적응 메커니즘

MCP는 단순히 데이터를 제공하는 정적인 파이프라인이 아니다. 프로토콜의 핵심에는 실시간으로 변화하는 대화의 흐름과 시스템의 상태에 맞춰 컨텍스트를 지능적으로 관리하고 최적화하는 동적인 시스템으로서의 정체성이 깊이 자리 잡고 있다.

### 2.1 고처리량(High-Throughput) 환경을 위한 상태 관리 아키텍처

수천 개의 동시 대화가 발생하는 대규모 AI 애플리케이션 환경에서는 컨텍스트의 일관성을 유지하고 파편화를 방지하는 것이 극도로 어렵다. MCP는 이러한 고처리량 시나리오를 염두에 두고 설계된 정교한 상태 관리 시스템을 통해 이 문제를 해결한다.14

- **실시간 동기화 (Real-time Synchronization):** 분산된 시스템 환경에서 특정 컨텍스트 정보가 변경되면, <u>해당 변경 사항이 필요한 모든 컴포넌트에 즉시 전파</u>된다. 이를 통해 여러 에이전트나 시스템이 동일한 정보를 참조할 때 발생할 수 있는 데이터 불일치와 그로 인한 혼란스러운 응답을 원천적으로 방지한다.
    
- **우선순위 기반 큐잉 (Priority-based Queuing):** 시스템에 수많은 요청이 몰리는 상황에서도, 중요도가 높은 컨텍스트 업데이트(예: 사용자의 즉각적인 명령과 관련된 정보)가 덜 중요한 백그라운드 작업에 의해 지연되지 않도록 보장한다. 이는 시스템의 체감 응답성을 유지하고 중요한 작업을 먼저 처리하는 핵심 메커니즘이다.
    
- **세션 지속성 (Session Persistence):** 일시적인 네트워크 장애나 서버의 재시작과 같은 예기치 않은 중단이 발생하더라도, 진행 중이던 대화의 맥락과 상태를 보존한다. 사용자는 서비스 중단을 거의 인지하지 못한 채 대화를 이어나갈 수 있으며, 이는 사용자 경험의 연속성을 보장하는 데 매우 중요하다.14 이 기능은 MCP가 근본적으로 상태 저장(stateful) 프로토콜임을 보여주는 가장 강력한 증거 중 하나다.16
    

이러한 상태 관리 기능에 더해, MCP는 성능 최적화를 위한 아키텍처를 갖추고 있다. 여러 컨텍스트 소스에 대한 쿼리를 순차적으로 처리하는 대신 동시에 병렬로 실행하여, 전체 지연 시간을 40-60%까지 획기적으로 단축한다. 또한, 자주 사용되는 컨텍스트를 인프라 전반에 걸쳐 분산 캐싱하여 불필요한 중복 조회를 피한다. 이러한 최적화를 통해 MCP는 초당 5,000개 이상의 컨텍스트 관련 작업을 100밀리초 미만의 응답 시간으로 처리할 수 있는 높은 성능을 달성한다.14

### 2.2 지능형 컨텍스트 적응 및 최적화 (Dynamic Context Adaptation)

MCP의 컨텍스트 관리는 정적인 데이터 제공을 넘어, 실시간 조건에 따라 컨텍스트 관리 전략 자체를 동적으로 조정하는 고급 기능을 포괄한다. 이는 AI 시스템의 성능과 사용자 경험을 최적화하기 위한 핵심적인 능력이다.

- **실시간 컨텍스트 조정:** 시스템은 다양한 실시간 지표를 기반으로 제공하는 컨텍스트의 양과 종류를 동적으로 조절한다. 예를 들어, 시스템 응답 시간이 느려지면 컨텍스트의 양을 줄이거나, 사용자가 특정 유형의 정보와 자주 상호작용하는 패턴을 보이면 해당 유형의 컨텍스트를 우선적으로 제공하는 식이다. 시스템 전체의 부하 상태에 따라서도 컨텍스트 제공 전략을 조정하여 안정성을 유지한다.

- **지능형 컨텍스트 라우팅:** 사용자의 요청이나 작업의 특성에 따라 최적의 컨텍스트 소스(서버)로 요청을 동적으로 라우팅한다. 예를 들어, 높은 정확도가 필요하지만 비용이 비싼 데이터 소스와, 정확도는 약간 낮지만 비용이 저렴하고 빠른 데이터 소스가 있을 때, 요청의 중요도에 따라 적절한 소스를 선택할 수 있다. 또한 여러 서버에 걸쳐 부하를 분산시켜 특정 서버의 과부하를 방지하는 로드 밸런싱 기능도 수행한다.

이러한 동적 적응 기능은 포괄적인 실시간 모니터링(성능, 품질, 비용), 규칙 기반 또는 머신러닝 기반의 적응형 알고리즘, 그리고 사용자 및 시스템으로부터의 피드백을 지속적으로 통합하는 피드백 루프를 통해 구현된다.17 이처럼 MCP의 컨텍스트 관리는 단순히 데이터를 가져오는 '데이터 제공' 행위를 넘어, 성능, 비용, 사용자 행동 등 <span style="background:#fff88f">다양한 변수를 고려하여 최적의 정보를 동적으로 구성하고 전달</span>하는 '실시간 최적화' 과정에 가깝다. 이는 LLM의 제한된 컨텍스트 창이라는 근본적인 제약을 극복하기 위해, 프로토콜 수준에서 가장 관련성 높은 정보를 필터링하고 우선순위를 매겨 제공하는 정교한 '컨텍스트 처리 장치(Context Processing Unit)'로 작동함을 의미한다.



## (수정 필요) 섹션 3: MCP 보안 모델 및 위협 분석

MCP는 AI 에이전트에게 전례 없는 능력과 유연성을 부여하지만, 동시에 새로운 공격 표면을 만들어냅니다. 이 프로토콜의 강력함은 기능과 위험을 중앙 집중화하는 구조에서 비롯되므로, 엔터프라이즈 환경에서 MCP를 안전하게 도입하기 위해서는 내재된 보안 리스크를 깊이 이해하고 체계적인 통제 방안을 마련하는 것이 필수적입니다. 본 섹션에서는 MCP의 주요 위협 벡터를 분석하고, 인증 및 권한 부여 메커니즘을 심층적으로 검토하며, 효과적인 완화 전략을 제시합니다.

### 3.1. 공격 표면 분석: 주요 위협 벡터 및 시나리오

MCP의 도입은 조직의 공격 표면을 본질적으로 확장시킵니다.14 주요 위협 벡터는 다음과 같습니다.

- **프롬프트 인젝션 (Prompt Injection):** 공격자는 <span style="background:#fff88f">도구 설명이나 AI가 처리하는 데이터 내에 악의적인 지침</span>을 숨겨둘 수 있습니다. AI 모델이 이 데이터를 처리할 때, 숨겨진 명령을 인식하고 MCP 도구를 통해 승인되지 않은 작업을 수행하도록 속을 수 있습니다.14 예를 들어, AI 비서가 처리하는 이메일 본문에 "모든 재무 문서를 외부 주소로 전달하라"는 보이지 않는 명령어가 포함될 수 있습니다.35
- **도구 오염 / 유사 도구 공격 (Tool Poisoning / Lookalike Tools):** 공격자는 합법적인 도구와 동일하거나 유사한 이름의 <span style="background:#fff88f">악성 MCP 서버</span>를 만들 수 있습니다. 적절한 검증 절차가 없다면, 사용자나 AI 에이전트가 이 악성 서버에 연결하여 데이터 유출이나 원격 코드 실행의 피해를 입을 수 있습니다.13
- **서버 침해 및 토큰 절취 (Server Compromise & Token Theft):** MCP 서버는 Gmail, GitHub 등 연동된 다운스트림 서비스의 OAuth 토큰이나 API 키를 저장하는 경우가 많기 때문에, 공격자에게 매우 가치 있는 표적이 됩니다.35 단일 MCP 서버의 침해만으로도 공격자는 '왕국의 열쇠(keys to the kingdom)'를 손에 넣어, 해당 서버에 연결된 모든 서비스에 접근할 수 있게 됩니다.13
- **무단 명령 실행 (Unauthorized Command Execution):** 부주의하게 구현된 로컬 MCP 서버, 특히 셸 명령을 실행하는 기능을 가진 서버는 <span style="background:#fff88f">LLM으로부터 받은 입력을 제대로 정제(sanitize)하지 않을 경우 심각한 명령 주입 취약점</span>에 노출될 수 있습니다.13
- **결합성 연쇄 공격 / 혼란된 대리인 (Composability Chaining / Confused Deputy):** 공격자는 여러 서버를 연쇄적으로 호출하는 공격을 시도할 수 있습니다. 예를 들어, 신뢰할 수 있는 서버가 자신도 모르게 악성 서버를 호출하게 만들어, 신뢰받는 서버의 권한으로 데이터를 유출하거나 명령을 실행하게 할 수 있습니다.13
- **섀도우 MCP (Shadow MCP):** MCP 서버를 손쉽게 구축할 수 있다는 점은 '섀도우 IT' 리스크를 야기합니다. 직원들이 보안팀의 인지나 통제 없이 검증되지 않은 불완전한 서버를 조직의 리소스 위에서 실행할 수 있으며, 이는 심각한 보안 사각지대를 만듭니다.14

### 3.2. 인증 및 권한 부여 메커니즘 심층 분석

MCP의 보안 모델은 빠르게 성숙하고 있지만, 여전히 신중한 접근이 필요한 영역이 존재합니다.

- **OAuth 2.1 프레임워크:** 프로토콜은 원격 서버의 주된 인증 프레임워크로 OAuth 2.1을 명시하고 있습니다.3 이는 업계 표준이며 잘 알려진 방식입니다. 하지만 초기 명세는 현대적인 기업의 관행과 일부 충돌하는 부분이 있었고, 커뮤니티의 피드백을 통해 개선 노력이 이루어지고 있습니다.36 2025년 6월 업데이트에서 MCP 서버를 <span style="background:#fff88f">OAuth 리소스 서버로 분류하고 리소스 표시자(Resource Indicators) 사용을 의무화</span>한 것은 토큰 유출 및 오용을 방지하기 위한 직접적인 대응 조치입니다.5
- **세분화된 권한의 필요성:** 현재의 중대한 리스크 중 하나는 MCP 도구가 종종 필요 이상으로 광범위한 권한(예: 읽기 전용 접근이면 충분한데도 Gmail 전체 접근 권한 요청)을 요구한다는 점입니다.14 이 문제를 해결하기 위해, 공식 로드맵에는 도구가 수행할 수 있는 작업을 보다 정밀하게 제어할 수 있는 '세분화된 권한 부여(fine-grained authorization)' 메커니즘 개발 계획이 포함되어 있습니다.37
- **선택적인 인증의 위험성:** 현재 MCP 명세는 인증을 '선택 사항'으로 규정하고 있는데, 이는 STDIO 방식이 아닌 모든 원격 통신에서 심각한 보안 허점이 될 수 있습니다. 보안 전문가들은 원격 구현에서는 인증을 의무화해야 한다고 강력히 권고합니다.38

### 3.3. 공급망 및 실행 환경의 보안 리스크

MCP 서버 자체와 이를 둘러싼 생태계 또한 잠재적인 보안 위협의 원천입니다.

- **신뢰할 수 없는 서버:** MCP 서버는 실행 가능한 코드이므로, 사용자는 신뢰할 수 있고 검증된 출처의 서버에만 연결해야 합니다.36 커뮤니티 기반의 레지스트리나 마켓플레이스가 확산됨에 따라, 서버의 출처와 무결성을 검증하는 것이 매우 중요해졌습니다.39
- **소프트웨어 공급망 공격:** 다른 모든 소프트웨어와 마찬가지로 MCP 서버와 클라이언트도 공급망 공격에 취약합니다. 개발 과정에서 구성 요소에 대한 <u>암호화 서명, 의존성 검사(SCA), 정적 분석(SAST)과 같은 표준 애플리케이션 보안(AppSec) 관행을 철저히 준수</u>해야 합니다.36
- **샌드박싱(Sandboxing):** 특히 파일 시스템 접근이나 셸 실행과 같이 강력한 권한을 가진 로컬 서버의 경우, 침해 시 <span style="background:#fff88f">잠재적 영향을 최소화하기 위해 샌드박스 환경에서 실행</span>하는 것이 필수적인 완화 조치입니다.36

### 3.4. 권장 완화 전략 및 제어 방안

이러한 다층적인 위협에 대응하기 위해서는 기술적, 정책적 통제가 결합된 심층 방어 전략이 필요합니다.

| 위협 벡터                 | 설명 및 예시 시나리오                                                                                                               | 권장 완화 전략                                                                                                                                                | 관련 자료 |
| ------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------- |
| **프롬프트 인젝션**       | 도구 설명이나 처리 데이터에 숨겨진 악성 명령을 주입하여 AI가 무단 작업을 수행하도록 유도. (예: 이메일 내용에 파일 유출 명령 숨기기) | • 입력 데이터 정제 및 필터링 • 중요 작업에 대한 **인간 참여(Human-in-the-Loop)** 승인 절차 도입 • 출력 내용에 대한 엄격한 검증                                | 14        |
| **도구 오염 / 유사 도구** | 공격자가 합법적인 도구와 유사한 이름의 악성 MCP 서버를 배포. 사용자가 실수로 연결 시 데이터 유출 발생.                              | • **검증된 서버 레지스트리** 및 마켓플레이스 사용 • **MCP 게이트웨이**를 통한 허용 목록(allow-list) 기반 정책 시행 • 서버의 암호화 서명 검증                  | 13        |
| **서버 침해 / 토큰 절취** | MCP 서버가 다운스트림 서비스의 인증 토큰을 저장하므로, 서버 침해 시 연결된 모든 서비스의 권한이 탈취될 수 있음.                     | • 최소 권한 원칙 준수 (필요한 최소한의 범위만 요청) • 서버 및 토큰 저장소에 대한 강력한 접근 제어 • **런타임 모니터링**을 통한 비정상적 API 호출 탐지         | 13        |
| **무단 명령 실행**        | 로컬 서버가 LLM의 출력을 정제하지 않고 셸 명령으로 실행할 경우, 명령 주입 공격에 취약.                                              | • 모든 외부 입력에 대한 엄격한 유효성 검사 및 정제 • 로컬 서버를 **샌드박스** 환경에서 실행하여 권한 제한 • 실행될 명령에 대한 명시적인 사용자 확인           | 13        |
| **혼란된 대리인 공격**    | 신뢰받는 서버가 자신도 모르게 악성 서버를 호출하여, 신뢰받는 서버의 권한으로 악성 행위를 수행.                                      | • **MCP 게이트웨이**를 통한 아웃바운드 트래픽 통제 및 로깅 • 서버 간 호출에 대한 명시적인 신뢰 관계 설정 및 검증                                              | 13        |
| **섀도우 MCP**            | 직원들이 보안 통제 없이 조직 리소스에 검증되지 않은 MCP 서버를 설치 및 운영하여 보안 사각지대 발생.                                 | • 조직 내 MCP 서버 사용에 대한 명확한 정책 수립 및 교육 • 네트워크 스캐닝을 통한 미승인 서버 탐지 • **MCP 게이트웨이**를 통한 중앙 집중식 관리 및 가시성 확보 | 14        |

MCP 아키텍처는 기능과 위험을 동시에 중앙 집중화하는 특성을 가집니다. 이는 엔터프라이즈 환경에서 **MCP 게이트웨이**와 같은 중앙 집중식 보안 통제 계층이 사실상 선택이 아닌 필수 요건임을 시사합니다.40 API 게이트웨이와 유사하게, MCP 게이트웨이는 인증, 권한 부여, 트래픽 관리, 로깅, 정책 집행을 위한 단일 지점을 제공하여, 분산된 MCP 생태계에서 발생하는 복잡한 보안 문제를 효과적으로 관리할 수 있습니다.

현재 MCP의 보안 모델은 커뮤니티의 피드백과 공개적인 연구를 통해 반응적으로, 그러나 매우 빠르게 성숙해 나가는 단계에 있습니다. 초기 명세의 허점을 커뮤니티가 지적하고, 프로토콜 유지 관리 주체인 앤스로픽(Anthropic)이 이를 수용하여 신속하게 개선하는 투명하고 건강한 프로세스가 작동하고 있습니다.5 이러한 역동적인 성숙 과정은 MCP가 장기적으로 신뢰할 수 있는 보안 기반을 갖추게 될 것이라는 긍정적인 신호로 해석될 수 있습니다.



- **개발자를 위한 권장 사항:** 공식 SDK를 적극적으로 활용하고 38, 모듈식의 단일 목적 서버를 구축하는 데 집중해야 합니다.40 안전하고 구성 가능한 도구를 만들기 위해 위임된 권한 부여 패턴에 특히 주의를 기울여야 합니다.
    
- **보안 팀을 위한 권장 사항:** 심층 방어 전략을 우선시해야 합니다. 프로토콜 수준의 보안에만 의존해서는 안 되며, AI 게이트웨이, 비정상적인 행동에 대한 런타임 모니터링(특히 ATPA 탐지), 서버 환경의 엄격한 샌드박싱과 같은 아키텍처 제어를 구현해야 합니다. 모든 서버 메타데이터는 검증될 때까지 신뢰할 수 없는 것으로 간주해야 합니다.
    
- **엔터프라이즈 도입자를 위한 권장 사항:** 위험이 낮고 가치가 높은 사용 사례부터 시작하는 것이 좋습니다. 표준화된 OAuth 2.1 흐름을 활용하여 MCP를 기존 엔터프라이즈 ID 및 접근 관리 시스템과 통합해야 합니다. 민감한 데이터에 대한 광범위한 접근을 허용하기 전에 MCP 서버를 심사, 배포 및 모니터링하기 위한 거버넌스 프레임워크 개발에 투자해야 합니다.


## 섹션 2: 엔터프라이즈 도입을 위한 다층적 보안 프레임워크

엔터프라이즈 환경에서 새로운 기술을 도입할 때 가장 중요한 고려사항은 보안입니다. MCP의 강력한 기능과 유연성은 필연적으로 새로운 공격 표면을 만들어냅니다. 따라서 MCP의 보안 모델을 포괄적이고 비판적으로 검토하는 것은 필수적입니다. 이 섹션에서는 기술 사양, 학술 연구, 위협 인텔리전스 보고서의 정보를 종합하여 MCP의 보안 위험과 완화 전략에 대한 전체적인 시각을 구축하고, 엔터프라이즈급 보안을 위한 다층적 방어 체계를 제시합니다.

### 2.1. 엔터프라이즈급 인증 및 권한 부여 모델

MCP는 원격 서버에 대한 강력하고 표준화된 보안 모델을 의무화함으로써 엔터프라이즈 준비 상태를 향한 중요한 발걸음을 내디뎠습니다. 이 모델은 **OAuth 2.1**을 기반으로 하며, 다음과 같은 핵심 구성 요소를 포함합니다:

- **PKCE (Proof Key for Code Exchange) 의무화:** 모든 클라이언트에 대해 PKCE가 요구되어, 권한 부여 코드 가로채기 공격을 방지합니다. 이는 특히 모바일 및 웹 애플리케이션과 같은 공용 클라이언트의 보안을 강화하는 데 필수적입니다.
    
- **서버 메타데이터 검색:** 클라이언트는 OAuth 2.0 서버 메타데이터(RFC8414)를 구현하여, 잘 알려진 URL(`/.well-known/oauth-protected-resource`)을 통해 서버의 권한 부여 엔드포인트(예: `/authorize`, `/token`)를 동적으로 검색해야 합니다. 이는 클라이언트 구성을 단순화하고 수동 설정의 오류 가능성을 줄입니다.
    
- **동적 클라이언트 등록 (DCR):** 프로토콜은 RFC7591을 지원하여 클라이언트가 새로운 서버에 자동으로 등록할 수 있도록 권장합니다. 이는 동적인 생태계에서 원활한 사용자 경험을 위해 중요합니다.17 다만, 로드맵에서는 운영상의 어려움으로 인해 대안을 모색 중이라고 언급하고 있습니다.
    
- **위임된(Third-Party) 권한 부여:** 사양은 MCP 서버가 업스트림 서비스(예: Google, GitHub)에 대한 OAuth 클라이언트 역할을 하는 흐름을 정의합니다. 이 모델에서 <u>MCP 서버는 업스트림 서비스로부터 토큰을 획득한 후, MCP 클라이언트에게는 더 좁은 범위의 자체 토큰을 발급</u>합니다. 이는 보안 경계를 생성하여 클라이언트가 업스트림 서비스에 대한 광범위한 접근 권한을 획득하는 것을 방지하고, 최소 권한 원칙을 강제하는 효과적인 방법입니다.
    
- **엔터프라이즈 통합:** 이 모델은 기업의 SSO(Single Sign-On) 및 IdP(Identity Provider)와 통합되도록 명시적으로 설계되어, 기업 환경의 핵심 요구사항을 충족합니다.

OAuth 2.1 흐름의 공식화는 MCP를 실행 가능한 엔터프라이즈 기술로 만드는 가장 중요한 단계입니다. 이는 보안을 구현별 부가 기능이 아닌 프로토콜의 핵심적이고 표준화된 부분으로 격상시킵니다. 특히 위임된 권한 부여 패턴은 '폭발 반경(blast radius)'을 제한하는 핵심 보안 문제를 해결하므로 매우 통찰력 있는 설계라 할 수 있습니다.


**표 2: 엔터프라이즈 인증 및 권한 부여 흐름 (OAuth 2.1)**

|**단계**|**작업**|**수행 주체**|**프로토콜/메커니즘**|**핵심 내용**|
|---|---|---|---|---|
|1. 검색|MCP 서버의 권한 부여 엔드포인트 검색|MCP 클라이언트|RFC8414 (Server Metadata)|클라이언트는 `/.well-known/oauth-protected-resource`를 쿼리하여 서버의 메타데이터를 가져옴|
|2. 클라이언트 등록|MCP 서버의 인증 서버에 클라이언트 등록|MCP 클라이언트|RFC7591 (DCR)|동적으로 클라이언트를 등록하여 `client_id`를 획득 (선택적)|
|3. 사용자 권한 부여|사용자를 인증 서버로 리디렉션하여 로그인 및 동의 요청|클라이언트, 사용자, 인증 서버|OAuth 2.1 Authorization Code Flow|사용자는 요청된 범위(scope)에 동의하고, 클라이언트는 권한 부여 코드를 받음|
|4. 토큰 교환|권한 부여 코드를 액세스 토큰과 교환|MCP 클라이언트, 인증 서버|PKCE|클라이언트는 코드를 토큰 엔드포인트로 전송하여 액세스 토큰 및 리프레시 토큰을 획득|
|5. 인증된 요청|보호된 리소스에 액세스하기 위해 액세스 토큰 사용|MCP 클라이언트, MCP 서버|HTTP Bearer Token|클라이언트는 모든 요청의 `Authorization` 헤더에 베어러 토큰을 포함하여 MCP 서버에 전송|
|6. 토큰 갱신|액세스 토큰이 만료되면 리프레시 토큰을 사용하여 새 토큰 획득|MCP 클라이언트, 인증 서버|OAuth 2.1 Refresh Token|세션을 유지하기 위해 새로운 액세스 토큰을 발급받음|

### 2.2. 위협 모델링 및 고급 공격 벡터 분석

MCP의 강력함은 새로운 위협을 동반합니다. 보안 연구원들은 MCP 생태계에 특화된 여러 심각한 취약점을 식별했으며, 이에 대한 이해는 방어 전략 수립의 첫걸음입니다.8

- **도구 중독(Tool Poisoning):** 이는 MCP에 가장 특화되고 위험한 위협으로 간주됩니다. 공격자는 악의적인 MCP 서버를 통해 사용자에게는 보이지 않지만 LLM 에이전트에게는 보이는 숨겨진 지침을 도구 설명(docstring)에 포함시킵니다. LLM은 이 설명을 신뢰하고 악의적인 명령을 그대로 실행하게 됩니다. 이 공격에는 여러 변종이 존재합니다.

    - **라인 점핑(Line Jumping):** 악의적인 지침이 합법적인 도구 호출보다 _먼저_ 실행되도록 배치하는 기법입니다.
    - **전체 스키마 중독(Full-Schema Poisoning, FSP):** 공격 표면을 단순한 `description` 필드를 넘어 매개변수 이름, 유형, `required` 필드 등 도구의 전체 JSON 스키마로 확장합니다.
    - **고급 도구 중독 공격(Advanced Tool Poisoning Attack, ATPA):** 도구의 _출력_ 을 조작하여 LLM을 속이는 2차 공격을 유도합니다. 예를 들어, "오류 해결을 위해" 민감한 파일을 읽도록 유도하는 프롬프트를 도구 출력에 포함시키는 방식입니다.

- **도구 섀도잉/하이재킹(Tool Shadowing/Hijacking):** 악의적인 서버가 신뢰할 수 있는 서버의 도구를 "그림자처럼" 따라다니며 하이재킹하는 공격입니다. 예를 들어, 가짜 "계산기" 도구가 신뢰할 수 있는 "이메일" 도구를 통해 전송되는 모든 이메일을 가로채 공격자에게 전달하도록 <u>숨겨진 지침을 포함</u>할 수 있습니다.
    
- **혼란된 대리인 문제(Confused Deputy Problem):** 높은 권한을 가진 MCP 서버가 <u>낮은 권한을 가진 사용자의 요청에 속아 대신 작업을 수행</u>함으로써 최소 권한 원칙을 위반하는 고전적인 보안 문제입니다. 표준화된 OAuth 흐름은 이 문제에 대한 주요 완화책입니다.
    
- **공급망 및 레지스트리 위험:** 검증되지 않은 공개 MCP 서버 레지스트리는 악성 코드 배포의 벡터가 될 수 있습니다. 사용자가 신뢰할 수 없는 출처에서 <u>악성 서버를 설치할 위험</u>이 존재합니다.29 이는 코드 서명 및 패키지 ID 검증과 같은 공급망 보안 조치의 필요성을 강조합니다.
    

이러한 위협의 핵심은 인간 사용자가 보는 것과 LLM 에이전트가 처리하는 것 사이의 **의미론적 격차(semantic gap)** 를 악용하는 데 있습니다. 공격자들은 LLM이 추론에 사용하는 메타데이터 계층(도구 스키마)을 오염시킵니다. 이는 에이전트 시스템의 근본적인 문제이며, MCP의 표준화된 구조는 이를 예측 가능한 공격 대상으로 만듭니다.

### 2.3. 방어 아키텍처 및 완화 전략

MCP 배포를 보호하기 위해서는 전통적인 보안 제어를 넘어서는 심층 방어(defense-in-depth) 접근 방식이 필요합니다.

- **클라이언트 측 방어:** 클라이언트는 서버가 제공하는 메타데이터를 맹목적으로 신뢰해서는 안 됩니다. <u>도구 설명을 정제(sanitize)하고 검증하여 의심스러운 지침을 제거하거나 플래그를 지정</u>해야 합니다. 또한, 사용자가 수행되는 작업을 명확하게 인지하고 제어할 수 있도록 UI/UX를 설계하는 것이 중요합니다.
- **서버 측 방어:** <u>서버는 강력한 인증 및 권한 부여 메커니즘</u>을 구현해야 합니다. 또한, 커맨드 인젝션과 같은 전통적인 취약점으로부터 코드를 강화해야 합니다.
- **아키텍처 방어 (AI 게이트웨이):** 배포 규모가 커짐에 따라 **AI 게이트웨이**가 중앙 집중식 정책 시행 지점 역할을 할 수 있습니다. 이는 <u>인증, 권한 부여, 속도 제한, 캐싱 및 트래픽 관리를 처리하여 보안 로직을 중앙 집중화하고 서버 개발을 단순화</u>합니다.11
- **런타임 감사 및 정책 시행:** 도구 호출에서 비정상적인 패턴(예: 갑자기 파일 접근을 요청하는 도구)을 지속적으로 모니터링해야 합니다. Cerbos와 같은 정책 엔진을 사용하여 런타임에 세분화된 속성 기반 접근 제어(RBAC/ABAC)를 적용하고, 특정 조건 하에서 어떤 사용자에게 어떤 도구를 사용할 수 있는지 결정할 수 있습니다.
- **샌드박싱 및 격리:** MCP 서버를 <u>최소한의 권한만 가진 격리된 환경(컨테이너, VM)에서 실행</u>하여 침해 사고 발생 시 피해 범위를 제한해야 합니다.

이러한 정교한 위협과 다층적 방어 전략의 등장은 "AI 방화벽"이라는 새로운 보안 범주의 출현을 예고합니다. 이는 단순한 웹 애플리케이션 방화벽(WAF)이나 API 게이트웨이가 아니라, AI와 도구 간 통신의 의미론적 내용을 검사하고 제어하도록 특별히 설계된 보안 계층입니다. 전통적인 방화벽이 네트워크(L3/L4) 및 애플리케이션(L7) 계층에서 작동하며 알려진 공격 시그니처를 검사하는 반면, 도구 중독과 같은 MCP 위협은 더 높은 의미론적 계층에서 작동합니다. JSON-RPC 페이로드는 구문적으로는 완벽하게 유효할 수 있지만, LLM에 대한 그 _의미_ 가 악의적일 수 있습니다. 이를 방어하기 위한 도구 스키마의 정적 분석이나 비정상적 행동에 대한 런타임 감사와 같은 완화책은 통신의 _의도_ 를 이해해야 합니다. 따라서 "AI 방화벽"은 게이트웨이에서 <span style="background:#fff88f">심층적인 의미론적 검사를 수행</span>해야 할 것입니다. 예를 들어, 주 에이전트에게 정보를 전달하기 전에 숨겨진 프롬프트나 악의적인 의도가 있는지 분석하기 위해 또 다른 "가드레일" LLM을 사용할 수 있습니다.30 이는 보안 인프라가 구문적 검증에서 의미론적 검증으로 진화하는 근본적인 변화를 나타내며, MCP와 같은 프로토콜 위에 구축된 자율 에이전트 생태계를 보호하기 위한 필수적인 단계입니다.

**표 3: MCP 공격 벡터 분석 및 완화 프레임워크**

|**위협 벡터**|**설명**|**공격 표면**|**잠재적 영향**|**완화 전략 (클라이언트)**|**완화 전략 (서버/아키텍처)**|
|---|---|---|---|---|---|
|도구 중독 (FSP, ATPA)|도구 설명/스키마/출력에 악성 지침을 삽입하여 LLM을 조종|`tools/list` 응답의 JSON 스키마, `tool/result` 응답|데이터 유출, 무단 작업 수행, 원격 코드 실행|도구 설명 정제 및 검증, UI에서 전체 설명 표시, 사용자 승인 강화|AI 게이트웨이에서 스키마 검증, 런타임 이상 행위 탐지(ATPA), 최소 권한 원칙 적용|
|도구 섀도잉|악성 서버가 신뢰할 수 있는 서버의 도구 동작을 하이재킹|`tools/list` 응답의 도구 설명|신뢰할 수 있는 도구를 통한 데이터 유출 또는 작업 조작|신뢰할 수 있는 서버 소스만 허용, 도구 네임스페이스 충돌 감지|서버 레지스트리에서 서명 및 출처 확인, 게이트웨이에서 정책 기반 라우팅|
|공급망 공격|악성 MCP 서버가 레지스트리나 비공식 채널을 통해 배포됨|MCP 서버 설치 파일, 레지스트리|시스템 침해, 영구적인 백도어 설치|신뢰할 수 있는 레지스트리만 사용, 서버 코드 검토|코드 서명 의무화, 패키지 ID 검증, 레지스트리 보안 강화|
|혼란된 대리인|낮은 권한의 사용자가 높은 권한의 서버를 속여 작업을 수행|권한 부여 및 인증 메커니즘|권한 상승, 무단 리소스 접근|-|OAuth 2.1 기반의 강력한 인증/권한 부여, 위임된 권한 부여 패턴 사용|
|서비스 거부(DoS)|과도한 요청이나 자율 에이전트 루프로 서버를 마비시킴|`tool/invoke` 및 기타 서버 엔드포인트|서비스 중단, 리소스 고갈|클라이언트 측 속도 제한 구현|AI 게이트웨이에서 중앙 집중식 속도 제한, 서킷 브레이커 패턴 적용|


## 마치며


> 본 포스트는 Google Gemini의 응답을 기반으로 저의 의견을 반영하여 다시 작성했습니다.