---
title: MCP 사용 시 고려사항
description: MCP를 적용하기 전, 어떤 점들을 고려해야 할지 알아보겠습니다.
date: 2025-08-18T19:03:00
lastmod: 2025-09-11
slug: consideration
comments: true
math: false
categories:
  - Systems
tags:
  - MCP
keywords:
  - MCP
---
## 개요

이번 포스트에서는 MCP 생태계를 구현할 때 보다 좋은 결과를 위해 내부 동작을 어떻게 활용하고, 요구사항을 위한 추가 기능을 위해 어떤 요소가 필요한지 알아보겠습니다.

## 섹션 4: 고급 아키텍처 고려사항 및 패턴

이 섹션에서는 정의된 프로토콜 사양을 넘어 실제 구현 과정에서 발생하는 복잡한 아키텍처 문제와 패턴을 다룹니다. 이는 프로토콜이 의도적으로 구현자, 특히 호스트에게 남겨둔 "어려운 문제들"을 해결하는 방법을 탐구합니다.

### 4.1. 상태 관리와 영속성: 메모리의 도전

#### 4.1.1. 상태 저장 세션의 본질: 인메모리 컨텍스트

MCP 세션은 그 생명주기 동안 상태를 유지합니다. 서버는 연결이 지속되는 동안 인메모리 컨텍스트 저장소를 유지하여 여러 요청에 걸쳐 상태를 기억할 수 있습니다. 하지만 중요한 점은, MCP 사양 자체는 사용자가 로그아웃했다가 다시 로그인하는 경우와 같이 세션을 넘어 이 상태를 영속시키는 메커니즘을 정의하지 않는다는 것입니다.

#### 4.1.2. 캐싱 전략과 동기화: `listChanged` 알림 메커니즘

성능 향상을 위해 호스트는 서버로부터 받은 도구 목록을 캐시합니다. 이 캐시가 오래된 정보가 되는 것을 방지하기 위해, 서버는 초기화 시 `listChanged: true` 기능을 선언할 수 있습니다. 만약 서버에서 사용 가능한 도구가 변경되면, 서버는 `notifications/tools/list_changed` <u>알림을 보냅니다.</u> 이 알림을 받은 호스트는 자신의 캐시가 오래되었음을 인지하고 `tools/list`를 다시 요청하여 도구 목록을 갱신합니다. 이 이벤트 기반 모델은 지속적으로 서버 상태를 확인하는 폴링(polling) 방식보다 훨씬 효율적입니다.

#### 4.1.3. 세션을 넘어서는 영속성: 아키텍처 패턴과 트레이드오프

프로토콜이 세션 간 영속성에 대해 명시하지 않으므로, 이는 호스트와 서버 개발자가 해결해야 할 아키텍처적 과제가 됩니다.

- **서버 측 패턴:** 서버는 자체적인 <u>영속성 저장소(예: 데이터베이스)에 연결</u>하고, OAuth와 같은 인증 토큰을 사용하여 상태를 특정 사용자와 연결할 수 있습니다. 이 경우 서버의 <span style="background:#fff88f">인메모리 상태는 일시적이지만, 백엔드 데이터는 영속성</span>을 가집니다.
    
- **호스트 측 패턴:** 호스트가 세션이 끝나기 전에 서버 리소스의 상태를 직렬화하여 저장하고, 나중에 새 세션에서 이를 복원하려고 시도할 수 있습니다. 그러나 프로토콜에 <u>이를 위한 표준 메커니즘이 없으므로 이는 비표준적인 협력</u>에 해당합니다.
    

### 4.2. 컨텍스트 집계와 충돌 해결: 호스트의 부담

#### 4.2.1. 단일 진실 공급원이자 보안 집행자로서의 호스트

호스트가 여러 서버에 연결될 때, 각 서버로부터 도구, 리소스, 프롬프트를 수신합니다. 이 모든 정보를 LLM을 위한 일관된 컨텍스트로 집계하는 책임은 전적으로 호스트에게 있습니다. 프로토콜은 이를 수행하는 방법에 대한 지침을 제공하지 않습니다.

#### 4.2.2. 도구 및 프리미티브 네임스페이스 관리 전략

가장 큰 문제 중 하나는 도구 이름의 충돌입니다. 만약 두 개의 다른 서버가 모두 `search`라는 이름의 도구를 제공한다면, 호스트는 이 충돌을 해결해야 합니다.

- **패턴 1: 접두사 붙이기 (Prefixing):** 호스트는 도구 이름에 <u>서버 이름을 접두사로 자동 추가</u>할 수 있습니다 (예: `github_search`, `slack_search`). FastMCP와 같은 일부 프레임워크는 이 기능을 지원합니다.
    
- **패턴 2: 사용자 선택 (User Selection):** 호스트의 UI에서 사용자가 모호함을 피하기 위해 특정 도구나 전체 서버를 활성화 또는 비활성화하도록 허용할 수 있습니다.
    

#### 4.2.3. 아키텍처 패턴: 우선순위 결정을 위한 계층적 컨텍스트 관리 (LCM)

**계층적 컨텍스트 관리(Layered Context Management, LCM)** 는 공식 MCP 사양의 일부는 아니지만, 호스트가 구현해야 할 매우 중요한 모범 사례 패턴입니다. 이는 최종 프롬프트 페이로드를 정의된 우선순위를 가진 논리적 계층으로 구조화하는 것을 포함합니다 (예: 시스템 프롬프트 > 도구 정의 > 대화 기록 > 사용자 쿼리). 이 구조를 통해 호스트는 컨텍스트가 LLM의 토큰 제한을 초과할 때, 단순한 잘라내기 대신 <u>가장 낮은 우선순위의 정보(예: 가장 오래된 대화 기록)부터 제거하는 지능적인 결정</u>을 내릴 수 있습니다.

#### 4.2.4. '혼란된 대리인' 위협 및 기타 보안 고려사항 완화

'혼란된 대리인(Confused Deputy)' 문제는 권한이 높은 프로그램(MCP 서버)이 권한이 낮은 개체(악의적인 프롬프트)에 속아 자신의 권한을 오용하게 되는 보안 취약점입니다.

- **완화 전략:** 이 문제의 해결 책임은 주로 호스트에게 있습니다. 호스트는 민감한 도구가 실행되기 전에 사용자에게 어떤 작업이 어떤 매개변수로 수행되는지 정확히 보여주는 명확한 UI를 통해 사용자 확인을 받아야 합니다. 또한, <u>서버에 최소한의 권한만 부여하는 제한된 API 키를 사용</u>하는 최소 권한 원칙을 적용해야 합니다.
    

프로토콜이 영속성 및 집계와 같은 고급 주제에 대해 "침묵"하는 것은 의도적인 설계 선택으로 볼 수 있습니다. 이러한 복잡한 작업에 대해 단일 방법을 규정하면 프로토콜이 경직되고 지나치게 복잡해질 수 있습니다. 이러한 책임을 호스트에게 위임함으로써 프로토콜은 핵심 통신 표준에 집중하면서 간결함을 유지합니다. 이 "침묵"은 애플리케이션 계층에서 혁신을 위한 공간을 창출합니다. 각기 다른 호스트는 자신의 특정 요구 사항(예: 간단한 IDE 플러그인 대 복잡한 엔터프라이즈 에이전트 플랫폼)에 따라 영속성, 캐싱, 컨텍스트 우선순위(LCM과 같은)에 대한 다양한 전략을 구현할 수 있습니다. 따라서 이러한 영역의 불완전한 명시는 버그가 아니라, 공통된 기반 위에 다양한 정교함을 가진 호스트 애플리케이션 생태계가 구축될 수 있도록 하여 프로토콜의 장기적인 생존 가능성과 적응성을 보장하는 기능입니다.



## Section 2: 동적 컨텍스트 관리 및 적응 메커니즘

MCP는 단순히 데이터를 제공하는 정적인 파이프라인이 아니다. 프로토콜의 핵심에는 실시간으로 변화하는 대화의 흐름과 시스템의 상태에 맞춰 컨텍스트를 지능적으로 관리하고 최적화하는 동적인 시스템으로서의 정체성이 깊이 자리 잡고 있다.

### 2.1 고처리량(High-Throughput) 환경을 위한 상태 관리 아키텍처

수천 개의 동시 대화가 발생하는 대규모 AI 애플리케이션 환경에서는 컨텍스트의 일관성을 유지하고 파편화를 방지하는 것이 극도로 어렵다. MCP는 이러한 고처리량 시나리오를 염두에 두고 설계된 정교한 상태 관리 시스템을 통해 이 문제를 해결한다.14

- **실시간 동기화 (Real-time Synchronization):** 분산된 시스템 환경에서 특정 컨텍스트 정보가 변경되면, <u>해당 변경 사항이 필요한 모든 컴포넌트에 즉시 전파</u>된다. 이를 통해 여러 에이전트나 시스템이 동일한 정보를 참조할 때 발생할 수 있는 데이터 불일치와 그로 인한 혼란스러운 응답을 원천적으로 방지한다.
    
- **우선순위 기반 큐잉 (Priority-based Queuing):** 시스템에 수많은 요청이 몰리는 상황에서도, 중요도가 높은 컨텍스트 업데이트(예: 사용자의 즉각적인 명령과 관련된 정보)가 덜 중요한 백그라운드 작업에 의해 지연되지 않도록 보장한다. 이는 시스템의 체감 응답성을 유지하고 중요한 작업을 먼저 처리하는 핵심 메커니즘이다.
    
- **세션 지속성 (Session Persistence):** 일시적인 네트워크 장애나 서버의 재시작과 같은 예기치 않은 중단이 발생하더라도, 진행 중이던 대화의 맥락과 상태를 보존한다. 사용자는 서비스 중단을 거의 인지하지 못한 채 대화를 이어나갈 수 있으며, 이는 사용자 경험의 연속성을 보장하는 데 매우 중요하다.14 이 기능은 MCP가 근본적으로 상태 저장(stateful) 프로토콜임을 보여주는 가장 강력한 증거 중 하나다.16
    

이러한 상태 관리 기능에 더해, MCP는 성능 최적화를 위한 아키텍처를 갖추고 있다. 여러 컨텍스트 소스에 대한 쿼리를 순차적으로 처리하는 대신 동시에 병렬로 실행하여, 전체 지연 시간을 40-60%까지 획기적으로 단축한다. 또한, 자주 사용되는 컨텍스트를 인프라 전반에 걸쳐 분산 캐싱하여 불필요한 중복 조회를 피한다. 이러한 최적화를 통해 MCP는 초당 5,000개 이상의 컨텍스트 관련 작업을 100밀리초 미만의 응답 시간으로 처리할 수 있는 높은 성능을 달성한다.14

### 2.2 지능형 컨텍스트 적응 및 최적화 (Dynamic Context Adaptation)

MCP의 컨텍스트 관리는 정적인 데이터 제공을 넘어, 실시간 조건에 따라 컨텍스트 관리 전략 자체를 동적으로 조정하는 고급 기능을 포괄한다. 이는 AI 시스템의 성능과 사용자 경험을 최적화하기 위한 핵심적인 능력이다.

- **실시간 컨텍스트 조정:** 시스템은 다양한 실시간 지표를 기반으로 제공하는 컨텍스트의 양과 종류를 동적으로 조절한다. 예를 들어, 시스템 응답 시간이 느려지면 컨텍스트의 양을 줄이거나, 사용자가 특정 유형의 정보와 자주 상호작용하는 패턴을 보이면 해당 유형의 컨텍스트를 우선적으로 제공하는 식이다. 시스템 전체의 부하 상태에 따라서도 컨텍스트 제공 전략을 조정하여 안정성을 유지한다.

- **지능형 컨텍스트 라우팅:** 사용자의 요청이나 작업의 특성에 따라 최적의 컨텍스트 소스(서버)로 요청을 동적으로 라우팅한다. 예를 들어, 높은 정확도가 필요하지만 비용이 비싼 데이터 소스와, 정확도는 약간 낮지만 비용이 저렴하고 빠른 데이터 소스가 있을 때, 요청의 중요도에 따라 적절한 소스를 선택할 수 있다. 또한 여러 서버에 걸쳐 부하를 분산시켜 특정 서버의 과부하를 방지하는 로드 밸런싱 기능도 수행한다.

이러한 동적 적응 기능은 포괄적인 실시간 모니터링(성능, 품질, 비용), 규칙 기반 또는 머신러닝 기반의 적응형 알고리즘, 그리고 사용자 및 시스템으로부터의 피드백을 지속적으로 통합하는 피드백 루프를 통해 구현된다.17 이처럼 MCP의 컨텍스트 관리는 단순히 데이터를 가져오는 '데이터 제공' 행위를 넘어, 성능, 비용, 사용자 행동 등 <span style="background:#fff88f">다양한 변수를 고려하여 최적의 정보를 동적으로 구성하고 전달</span>하는 '실시간 최적화' 과정에 가깝다. 이는 LLM의 제한된 컨텍스트 창이라는 근본적인 제약을 극복하기 위해, 프로토콜 수준에서 가장 관련성 높은 정보를 필터링하고 우선순위를 매겨 제공하는 정교한 '컨텍스트 처리 장치(Context Processing Unit)'로 작동함을 의미한다.

## 섹션 4: 건너야 할 협곡: 생태계 및 채택 과제

이 섹션은 MCP가 초기 채택자들을 위한 틈새 프로토콜에서 업계 전반의 표준으로 이동할 수 있을지를 결정할 더 넓은 시장 및 커뮤니티 과제를 평가한다.

### 4.1. 서버의 무법지대: 품질, 유지보수, 그리고 발견

생태계는 다양한 품질의 서버로 넘쳐난다. 많은 서버가 서둘러 출시되어 유지 관리가 부실하고, 버그가 많거나 사실상 방치되어 사용자 경험을 저해하고 보안 위험을 초래한다.27 한 Reddit 사용자는 15개의 서버 중 오버헤드가 이점을 초과하여 결국 4개의 핵심적이고 효과적인 서버만 사용하게 되었다고 언급했다.36 주요 생태계 격차는 사용 가능한 서버를 발견하기 위한 표준화된 네이티브 메커니즘의 부재이다.18 서버를 찾고 설정하는 것은 수동적이고 단편적인 과정이다.18

`mcp.so`와 같은 커뮤니티 주도 레지스트리가 등장하고 있지만, 표준화된 프로토콜 수준의 해결책이 필요하다.18 또한, 서버 제작자를 위한 명확한 수익 모델이 없다면 고품질의 안전하고 최신 서버를 유지할 인센티브가 거의 없어 생태계의 장기적인 건강을 위협한다.26

이러한 현실은 MCP 생태계가 현재 강력한 과대광고 주기와 훨씬 더 실용적인 효용 곡선 사이에 갇혀 있음을 시사한다. 데모는 인상적이지만, 실제 일상적인 효용은 종종 <u>잘 설계되고 문제에 특화된 소수의 서버에 국한</u>된다.36 서버를 추가하는 "많을수록 좋다"는 접근 방식은 높은 토큰 비용과 성능 저하를 초래하는 안티패턴이다.36 이는 MCP의 성공적인 경로가 수천 개의 평범한 도구로 이루어진 광대하고 무질서한 생태계가 아니라, 진정으로 고통스러운 문제를 해결하는 <span style="background:#fff88f">고품질의 신뢰할 수 있고 안전한 서버들의 선별된 집합</span>이라는 것을 암시한다. 약속은 플러그 앤 플레이 도구의 거대한 생태계이지만 3, 초기 채택자들은 많은 서버를 설치한 후 36 컨텍스트 토큰 오버헤드로 인한 성능 저하와 높은 비용을 경험한다.36 그들은 결국 소수의 매우 관련성 높은 서버만이 실제로 유용하다는 결론에 도달한다. 따라서 MCP 생태계의 가치는 그 _넓이_ 가 아니라 _깊이_ 와 _품질_ 에 있다. 커뮤니티의 과제는 서버의 양에서 품질과 신뢰성으로 초점을 옮기는 것이다.

### 4.2. 엔터프라이즈 채택 장벽: 개발자 우선 틈새 시장을 넘어서

3장에서 자세히 설명했듯이, 보안 문제는 기업 채택의 가장 큰 장애물이다.32 <span style="background:#fff88f">SSO, 감사 로깅, 규정 준수 추적과 같은 엔터프라이즈 기능의 부재</span>는 심각한 걸림돌이다.21 MCP를 채택하려면 <u>인프라, 보안, AI 전반에 걸친 전문 지식이 필요</u>하다.10 복잡한 레거시 시스템과의 통합 및 새로운 프로토콜에 대한 팀 교육은 많은 조직에 상당한 장애물을 제시한다.38 기술적 문제 외에도, 채택은 변화에 대한 저항과 명확한 전략적 로드맵의 부재와 같은 조직적 장벽에 직면한다. 성공적인 채택은 기술적 전환뿐만 아니라 문화적 변화를 요구한다.39

### 4.3. 누락된 인프라: 게이트웨이, 도구 및 거버넌스

채택이 확장됨에 따라, 특히 다중 테넌트 환경에서 <span style="background:#fff88f">표준화된 "MCP 게이트웨이" 계층이 필수</span>적이 되고 있다. 이러한 게이트웨이는 전통적인 API 게이트웨이와 유사하게 <u>인증, 권한 부여, 트래픽 관리 및 관찰 가능성을 중앙에서 처리</u>할 것이다.18 더 넓은 도구 생태계는 아직 초기 단계에 있다. MCP의 독특한 아키텍처를 위해 특별히 설계된 더 나은 서버 생성 도구, 테스트 프레임워크, 관찰 가능성 플랫폼이 필요하다.18 MCP는 새로운 데이터 거버넌스 복잡성을 야기한다. 데이터 접근의 동적인 특성은 감사 추적을 유지하고 GDPR과 같은 규정을 준수함을 입증하기 어렵게 만들며, 특히 데이터 집계 및 모니터링되지 않는 접근의 위험을 고려할 때 더욱 그렇다.32

MCP의 규범적이고 구조화된 특성 23은 안전과 표준화에 이롭지만, 아키텍처적 경직성의 위험을 내포한다. 한 해커뉴스 댓글은 이를 고퍼(Gopher) 대 웹(Web)에 비유하며, 그 경직된 구조가 다양성을 제한하고 더 빠르고 유연한 프로토콜에 의해 파괴될 수 있다고 주장했다.22 이는 중요한 장기적 전략적 위험이다. 만약 생태계가 보안 및 개발자 경험 문제를 충분히 빨리 해결하지 못한다면, 시장은 OpenAPI와 같이 덜 표준화되었지만 더 유연한 기반 위에 구축된 "충분히 좋은" 해결책을 선택할 수 있으며, MCP는 강력하지만 궁극적으로는 틈새 프로토콜로 남게 될 것이다.

### 3.1 확장성의 기반: 프리미티브(Primitives) 프레임워크

MCP 확장성의 핵심에는 '프리미티브(Primitives)'라는 개념이 있다. 프리미티브는 MCP 서버가 클라이언트에게 제공할 수 있는 기능의 표준화된 기본 단위로, 단순한 데이터 구조가 아닌 동적으로 발견하고 상호작용할 수 있는 명시적인 계약(contract)이다.

- **서버 제공 프리미티브:** 서버는 세 가지 핵심 프리미티브를 통해 자신의 능력을 외부에 노출한다.
    
    - **`Tools`:** 외부 시스템에서 특정 작업을 수행하는 실행 가능한 함수다. <span style="background:#fff88f">API를 호출하거나, 데이터베이스에 쿼리를 보내거나, 계산을 수행하는 등의 '행동'</span>을 담당한다. 클라이언트는 `tools/list` 메서드로 어떤 도구들이 있는지 발견하고, `tools/call` 메서드로 특정 도구를 실행한다.
    - **`Resources`:** LLM에 컨텍스트로 제공될 수 있는 파일과 같은 정적인 '데이터'를 의미한다. <span style="background:#fff88f">파일의 내용, API 응답 결과, 데이터베이스 레코드 등</span>이 이에 해당한다. 클라이언트는 `resources/list`로 사용 가능한 리소스 목록을 확인하고, `resources/get` (또는 `read`) 메서드로 그 내용을 가져온다.
    - **`Prompts`:** 일관된 LLM 상호작용을 유도하기 위한 재사용 가능한 프롬프트 템플릿이다. 이를 통해 복잡한 작업을 위한 프롬프트를 표준화하고 재사용성을 높일 수 있다.

이 프리미티브 프레임워크의 핵심은 **동적 발견 메커니즘**이다. 클라이언트는 세션을 시작할 때 `*/list` (예: `tools/list`) 메서드를 호출하여 런타임에 서버가 제공하는 모든 프리미티브를 동적으로 질의하고 목록을 받아올 수 있다. 이는 새로운 기능을 가진 서버 플러그인이 추가되더라도 클라이언트 코드를 전혀 변경할 필요가 없는, 진정한 '플러그 앤 플레이' 생태계를 가능하게 하는 기술적 기반이다.

### 3.2 양방향 상호작용을 위한 고급 프리미티브

MCP는 전통적인 클라이언트-서버 모델, 즉 클라이언트가 요청하고 서버가 응답하는 단방향 모델을 넘어선다. MCP의 가장 혁신적인 측면 중 하나는 서버가 역으로 클라이언트의 기능을 요청할 수 있는 양방향 상호작용을 지원한다는 점이며, 이는 자율적인 에이전트를 구현하는 핵심적인 차별점이다.

- **클라이언트 제공 프리미티브 (서버가 클라이언트에게 요청):**
    
    - **`Sampling`:** 이 프리미티브는 서버가 클라이언트(호스트 애플리케이션)가 보유한 LLM에게 추론(completion)을 요청할 수 있게 해준다. 예를 들어, 코드 분석 서버가 복잡한 코드 조각을 이해하기 위해 "이 코드의 목적은 무엇인가?"라는 질문을 클라이언트의 LLM에게 보내고 그 답변을 받아 자신의 분석에 활용할 수 있다. 이 기능 덕분에 서버 개발자는 <u>자체적으로 무거운 LLM을 내장하거나 특정 모델에 종속될 필요 없이</u>, 모델 독립적인 도구를 만들 수 있다.2
    - **`Elicitation`:** 서버가 작업을 수행하는 데 정보가 부족하거나 사용자의 확인이 필요할 때, 클라이언트를 통해 사용자에게 직접 정보를 요청하거나 확인을 받을 수 있는 기능이다. 예를 들어, 파일 삭제 도구는 실제로 파일을 삭제하기 전에 `Elicitation`을 통해 "정말로 이 파일을 삭제하시겠습니까?"라는 확인창을 사용자에게 띄우도록 클라이언트에 요청할 수 있다.2
    - **`Roots`:** 서버가 작업을 수행할 파일 시스템의 경계(boundary)나 현재 열려있는 프로젝트의 루트 디렉토리와 같은 작업 공간에 대한 정보를 클라이언트에 문의할 수 있게 한다.2
        

이러한 양방향 프리미티브는 단순한 '명령 실행자'였던 도구를, 스스로 판단하고 필요에 따라 다른 에이전트(클라이언트의 LLM 또는 사용자)의 능력을 활용하는 '협력적 추론 파트너'로 격상시킨다. 이는 여러 전문 에이전트가 협력하여 문제를 해결하는 분산형 에이전트 시스템(Multi-Agent System)으로 나아가는 중요한 기술적 발판이 된다.

**Table 2: MCP 고급 프리미티브 기능 분석**

| 프리미티브             | 주도자 | 핵심 기능 (서버가 클라이언트에게 요청하는 것)    | 기술적 의미                                          | 구현 가능한 고급 워크플로우 예시                                                  |
| ----------------- | --- | ----------------------------- | ----------------------------------------------- | ------------------------------------------------------------------- |
| **`Sampling`**    | 서버  | LLM 추론 (텍스트 완성) 요청            | - 서버의 모델 독립성 확보 - 도구의 추론 능력 확장 - 분산형 에이전트 추론    | 코드 리팩토링 서버가 제안을 생성하기 전에, 클라이언트의 LLM에게 코드의 의도를 분석해달라고 요청함.           |
| **`Elicitation`** | 서버  | 사용자로부터 추가 정보 입력 또는 확인 요청      | - Human-in-the-Loop 강화 - 대화형 도구 구현 - 동적 파라미터 수집 | 데이터베이스 마이그레이션 도구가 실행 전, 사용자에게 대상 데이터베이스의 비밀번호를 입력받거나 최종 실행 확인을 요청함. |
| **`Roots`**       | 서버  | 작업 공간의 경계 (파일 시스템 루트 등) 정보 요청 | - 컨텍스트 인식 작업 수행 - 보안 경계 설정 - 상대 경로 해석           | 정적 분석 도구가 전체 프로젝트를 스캔하기 위해, 클라이언트에게 현재 열린 프로젝트의 루트 디렉토리 경로를 요청함.    |


### 3.3 아키텍처의 구성 가능성(Composability)

MCP 아키텍처는 각 서버가 특정 기능에 집중하는 독립적인 모듈로 설계되도록 장려한다.3 예를 들어, GitHub 서버는 코드 저장소 관련 기능만 제공하고, Slack 서버는 메시징 기능에만 집중한다.

MCP의 진정한 잠재력은 단일 AI 애플리케이션(호스트)이 이렇게 전문화된 여러 MCP 서버에 동시에 연결하고, 이들로부터 얻은 컨텍스트와 도구를 동적으로 조합하여 복잡한 다단계 워크플로우를 구성하는 데서 발현된다.4 예를 들어, 한 SRE(Site Reliability Engineering) 엔지니어가 "지난 2시간 동안 checkout 서비스에서 발생한 지연 현상의 원인을 조사하고 관련 팀에 보고해줘"라고 요청했다고 가정해보자.

1. 호스트의 LLM은 먼저 SRE용 MCP 서버에 연결된 '메트릭 이상 탐지 도구'를 호출하여 비정상적인 지표를 확인한다.
    
2. 이상이 감지된 특정 서비스의 로그를 분석하기 위해, 동일한 서버의 '로그 쿼리 도구'를 호출한다.
    
3. 원인이 파악되면, 이번에는 Slack MCP 서버에 연결된 '메시지 전송 도구'를 호출하여 분석 결과를 담당 팀 채널에 게시한다.
    
4. 마지막으로 Jira MCP 서버의 '티켓 생성 도구'를 호출하여 공식적인 인시던트 티켓을 생성한다.
    

이처럼 프리미티브는 AI 에이전트 세계에 서비스 지향 아키텍처(SOA)를 구현하는 핵심 추상화 계층으로 기능한다. 각 MCP 서버는 독립적으로 배포 및 업데이트될 수 있는 마이크로서비스와 같으며, MCP 호스트는 이 서비스들을 동적으로 발견하고 조합하는 오케스트레이터 역할을 수행한다. 이 구조는 개발자들이 전체 시스템을 이해할 필요 없이 특정 기능의 서버만 개발하여 생태계에 기여할 수 있게 하며, 애플리케이션 개발자들은 필요한 서버들을 조합하여 강력한 AI 애플리케이션을 신속하게 구축할 수 있도록 한다. 이는 기능 개발과 애플리케이션 구축의 관심사를 명확히 분리(Separation of Concerns)하여 생태계 전체의 개발 효율성을 극대화하는 전략이다.

## (수정 필요) 섹션 3: MCP 보안 모델 및 위협 분석

MCP는 AI 에이전트에게 전례 없는 능력과 유연성을 부여하지만, 동시에 새로운 공격 표면을 만들어냅니다. 이 프로토콜의 강력함은 기능과 위험을 중앙 집중화하는 구조에서 비롯되므로, 엔터프라이즈 환경에서 MCP를 안전하게 도입하기 위해서는 내재된 보안 리스크를 깊이 이해하고 체계적인 통제 방안을 마련하는 것이 필수적입니다. 본 섹션에서는 MCP의 주요 위협 벡터를 분석하고, 인증 및 권한 부여 메커니즘을 심층적으로 검토하며, 효과적인 완화 전략을 제시합니다.

### 3.1. 공격 표면 분석: 주요 위협 벡터 및 시나리오

MCP의 도입은 조직의 공격 표면을 본질적으로 확장시킵니다.14 주요 위협 벡터는 다음과 같습니다.

- **프롬프트 인젝션 (Prompt Injection):** 공격자는 <span style="background:#fff88f">도구 설명이나 AI가 처리하는 데이터 내에 악의적인 지침</span>을 숨겨둘 수 있습니다. AI 모델이 이 데이터를 처리할 때, 숨겨진 명령을 인식하고 MCP 도구를 통해 승인되지 않은 작업을 수행하도록 속을 수 있습니다.14 예를 들어, AI 비서가 처리하는 이메일 본문에 "모든 재무 문서를 외부 주소로 전달하라"는 보이지 않는 명령어가 포함될 수 있습니다.35
- **도구 오염 / 유사 도구 공격 (Tool Poisoning / Lookalike Tools):** 공격자는 합법적인 도구와 동일하거나 유사한 이름의 <span style="background:#fff88f">악성 MCP 서버</span>를 만들 수 있습니다. 적절한 검증 절차가 없다면, 사용자나 AI 에이전트가 이 악성 서버에 연결하여 데이터 유출이나 원격 코드 실행의 피해를 입을 수 있습니다.13
- **서버 침해 및 토큰 절취 (Server Compromise & Token Theft):** MCP 서버는 Gmail, GitHub 등 연동된 다운스트림 서비스의 OAuth 토큰이나 API 키를 저장하는 경우가 많기 때문에, 공격자에게 매우 가치 있는 표적이 됩니다.35 단일 MCP 서버의 침해만으로도 공격자는 '왕국의 열쇠(keys to the kingdom)'를 손에 넣어, 해당 서버에 연결된 모든 서비스에 접근할 수 있게 됩니다.13
- **무단 명령 실행 (Unauthorized Command Execution):** 부주의하게 구현된 로컬 MCP 서버, 특히 셸 명령을 실행하는 기능을 가진 서버는 <span style="background:#fff88f">LLM으로부터 받은 입력을 제대로 정제(sanitize)하지 않을 경우 심각한 명령 주입 취약점</span>에 노출될 수 있습니다.13
- **결합성 연쇄 공격 / 혼란된 대리인 (Composability Chaining / Confused Deputy):** 공격자는 여러 서버를 연쇄적으로 호출하는 공격을 시도할 수 있습니다. 예를 들어, 신뢰할 수 있는 서버가 자신도 모르게 악성 서버를 호출하게 만들어, 신뢰받는 서버의 권한으로 데이터를 유출하거나 명령을 실행하게 할 수 있습니다.13
- **섀도우 MCP (Shadow MCP):** MCP 서버를 손쉽게 구축할 수 있다는 점은 '섀도우 IT' 리스크를 야기합니다. 직원들이 보안팀의 인지나 통제 없이 검증되지 않은 불완전한 서버를 조직의 리소스 위에서 실행할 수 있으며, 이는 심각한 보안 사각지대를 만듭니다.14

### 3.2. 인증 및 권한 부여 메커니즘 심층 분석

MCP의 보안 모델은 빠르게 성숙하고 있지만, 여전히 신중한 접근이 필요한 영역이 존재합니다.

- **OAuth 2.1 프레임워크:** 프로토콜은 원격 서버의 주된 인증 프레임워크로 OAuth 2.1을 명시하고 있습니다.3 이는 업계 표준이며 잘 알려진 방식입니다. 하지만 초기 명세는 현대적인 기업의 관행과 일부 충돌하는 부분이 있었고, 커뮤니티의 피드백을 통해 개선 노력이 이루어지고 있습니다.36 2025년 6월 업데이트에서 MCP 서버를 <span style="background:#fff88f">OAuth 리소스 서버로 분류하고 리소스 표시자(Resource Indicators) 사용을 의무화</span>한 것은 토큰 유출 및 오용을 방지하기 위한 직접적인 대응 조치입니다.5
- **세분화된 권한의 필요성:** 현재의 중대한 리스크 중 하나는 MCP 도구가 종종 필요 이상으로 광범위한 권한(예: 읽기 전용 접근이면 충분한데도 Gmail 전체 접근 권한 요청)을 요구한다는 점입니다.14 이 문제를 해결하기 위해, 공식 로드맵에는 도구가 수행할 수 있는 작업을 보다 정밀하게 제어할 수 있는 '세분화된 권한 부여(fine-grained authorization)' 메커니즘 개발 계획이 포함되어 있습니다.37
- **선택적인 인증의 위험성:** 현재 MCP 명세는 인증을 '선택 사항'으로 규정하고 있는데, 이는 STDIO 방식이 아닌 모든 원격 통신에서 심각한 보안 허점이 될 수 있습니다. 보안 전문가들은 원격 구현에서는 인증을 의무화해야 한다고 강력히 권고합니다.38

### 3.3. 공급망 및 실행 환경의 보안 리스크

MCP 서버 자체와 이를 둘러싼 생태계 또한 잠재적인 보안 위협의 원천입니다.

- **신뢰할 수 없는 서버:** MCP 서버는 실행 가능한 코드이므로, 사용자는 신뢰할 수 있고 검증된 출처의 서버에만 연결해야 합니다.36 커뮤니티 기반의 레지스트리나 마켓플레이스가 확산됨에 따라, 서버의 출처와 무결성을 검증하는 것이 매우 중요해졌습니다.39
- **소프트웨어 공급망 공격:** 다른 모든 소프트웨어와 마찬가지로 MCP 서버와 클라이언트도 공급망 공격에 취약합니다. 개발 과정에서 구성 요소에 대한 <u>암호화 서명, 의존성 검사(SCA), 정적 분석(SAST)과 같은 표준 애플리케이션 보안(AppSec) 관행을 철저히 준수</u>해야 합니다.36
- **샌드박싱(Sandboxing):** 특히 파일 시스템 접근이나 셸 실행과 같이 강력한 권한을 가진 로컬 서버의 경우, 침해 시 <span style="background:#fff88f">잠재적 영향을 최소화하기 위해 샌드박스 환경에서 실행</span>하는 것이 필수적인 완화 조치입니다.36

### 3.4. 권장 완화 전략 및 제어 방안

이러한 다층적인 위협에 대응하기 위해서는 기술적, 정책적 통제가 결합된 심층 방어 전략이 필요합니다.

| 위협 벡터                 | 설명 및 예시 시나리오                                                                                                               | 권장 완화 전략                                                                                                                                                | 관련 자료 |
| ------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------- |
| **프롬프트 인젝션**       | 도구 설명이나 처리 데이터에 숨겨진 악성 명령을 주입하여 AI가 무단 작업을 수행하도록 유도. (예: 이메일 내용에 파일 유출 명령 숨기기) | • 입력 데이터 정제 및 필터링 • 중요 작업에 대한 **인간 참여(Human-in-the-Loop)** 승인 절차 도입 • 출력 내용에 대한 엄격한 검증                                | 14        |
| **도구 오염 / 유사 도구** | 공격자가 합법적인 도구와 유사한 이름의 악성 MCP 서버를 배포. 사용자가 실수로 연결 시 데이터 유출 발생.                              | • **검증된 서버 레지스트리** 및 마켓플레이스 사용 • **MCP 게이트웨이**를 통한 허용 목록(allow-list) 기반 정책 시행 • 서버의 암호화 서명 검증                  | 13        |
| **서버 침해 / 토큰 절취** | MCP 서버가 다운스트림 서비스의 인증 토큰을 저장하므로, 서버 침해 시 연결된 모든 서비스의 권한이 탈취될 수 있음.                     | • 최소 권한 원칙 준수 (필요한 최소한의 범위만 요청) • 서버 및 토큰 저장소에 대한 강력한 접근 제어 • **런타임 모니터링**을 통한 비정상적 API 호출 탐지         | 13        |
| **무단 명령 실행**        | 로컬 서버가 LLM의 출력을 정제하지 않고 셸 명령으로 실행할 경우, 명령 주입 공격에 취약.                                              | • 모든 외부 입력에 대한 엄격한 유효성 검사 및 정제 • 로컬 서버를 **샌드박스** 환경에서 실행하여 권한 제한 • 실행될 명령에 대한 명시적인 사용자 확인           | 13        |
| **혼란된 대리인 공격**    | 신뢰받는 서버가 자신도 모르게 악성 서버를 호출하여, 신뢰받는 서버의 권한으로 악성 행위를 수행.                                      | • **MCP 게이트웨이**를 통한 아웃바운드 트래픽 통제 및 로깅 • 서버 간 호출에 대한 명시적인 신뢰 관계 설정 및 검증                                              | 13        |
| **섀도우 MCP**            | 직원들이 보안 통제 없이 조직 리소스에 검증되지 않은 MCP 서버를 설치 및 운영하여 보안 사각지대 발생.                                 | • 조직 내 MCP 서버 사용에 대한 명확한 정책 수립 및 교육 • 네트워크 스캐닝을 통한 미승인 서버 탐지 • **MCP 게이트웨이**를 통한 중앙 집중식 관리 및 가시성 확보 | 14        |

MCP 아키텍처는 기능과 위험을 동시에 중앙 집중화하는 특성을 가집니다. 이는 엔터프라이즈 환경에서 **MCP 게이트웨이**와 같은 중앙 집중식 보안 통제 계층이 사실상 선택이 아닌 필수 요건임을 시사합니다.40 API 게이트웨이와 유사하게, MCP 게이트웨이는 인증, 권한 부여, 트래픽 관리, 로깅, 정책 집행을 위한 단일 지점을 제공하여, 분산된 MCP 생태계에서 발생하는 복잡한 보안 문제를 효과적으로 관리할 수 있습니다.

현재 MCP의 보안 모델은 커뮤니티의 피드백과 공개적인 연구를 통해 반응적으로, 그러나 매우 빠르게 성숙해 나가는 단계에 있습니다. 초기 명세의 허점을 커뮤니티가 지적하고, 프로토콜 유지 관리 주체인 앤스로픽(Anthropic)이 이를 수용하여 신속하게 개선하는 투명하고 건강한 프로세스가 작동하고 있습니다.5 이러한 역동적인 성숙 과정은 MCP가 장기적으로 신뢰할 수 있는 보안 기반을 갖추게 될 것이라는 긍정적인 신호로 해석될 수 있습니다.



- **개발자를 위한 권장 사항:** 공식 SDK를 적극적으로 활용하고 38, 모듈식의 단일 목적 서버를 구축하는 데 집중해야 합니다.40 안전하고 구성 가능한 도구를 만들기 위해 위임된 권한 부여 패턴에 특히 주의를 기울여야 합니다.
    
- **보안 팀을 위한 권장 사항:** 심층 방어 전략을 우선시해야 합니다. 프로토콜 수준의 보안에만 의존해서는 안 되며, AI 게이트웨이, 비정상적인 행동에 대한 런타임 모니터링(특히 ATPA 탐지), 서버 환경의 엄격한 샌드박싱과 같은 아키텍처 제어를 구현해야 합니다. 모든 서버 메타데이터는 검증될 때까지 신뢰할 수 없는 것으로 간주해야 합니다.
    
- **엔터프라이즈 도입자를 위한 권장 사항:** 위험이 낮고 가치가 높은 사용 사례부터 시작하는 것이 좋습니다. 표준화된 OAuth 2.1 흐름을 활용하여 MCP를 기존 엔터프라이즈 ID 및 접근 관리 시스템과 통합해야 합니다. 민감한 데이터에 대한 광범위한 접근을 허용하기 전에 MCP 서버를 심사, 배포 및 모니터링하기 위한 거버넌스 프레임워크 개발에 투자해야 합니다.


## 섹션 2: 엔터프라이즈 도입을 위한 다층적 보안 프레임워크

엔터프라이즈 환경에서 새로운 기술을 도입할 때 가장 중요한 고려사항은 보안입니다. MCP의 강력한 기능과 유연성은 필연적으로 새로운 공격 표면을 만들어냅니다. 따라서 MCP의 보안 모델을 포괄적이고 비판적으로 검토하는 것은 필수적입니다. 이 섹션에서는 기술 사양, 학술 연구, 위협 인텔리전스 보고서의 정보를 종합하여 MCP의 보안 위험과 완화 전략에 대한 전체적인 시각을 구축하고, 엔터프라이즈급 보안을 위한 다층적 방어 체계를 제시합니다.

### 2.1. 엔터프라이즈급 인증 및 권한 부여 모델

MCP는 원격 서버에 대한 강력하고 표준화된 보안 모델을 의무화함으로써 엔터프라이즈 준비 상태를 향한 중요한 발걸음을 내디뎠습니다. 이 모델은 **OAuth 2.1**을 기반으로 하며, 다음과 같은 핵심 구성 요소를 포함합니다:

- **PKCE (Proof Key for Code Exchange) 의무화:** 모든 클라이언트에 대해 PKCE가 요구되어, 권한 부여 코드 가로채기 공격을 방지합니다. 이는 특히 모바일 및 웹 애플리케이션과 같은 공용 클라이언트의 보안을 강화하는 데 필수적입니다.
    
- **서버 메타데이터 검색:** 클라이언트는 OAuth 2.0 서버 메타데이터(RFC8414)를 구현하여, 잘 알려진 URL(`/.well-known/oauth-protected-resource`)을 통해 서버의 권한 부여 엔드포인트(예: `/authorize`, `/token`)를 동적으로 검색해야 합니다. 이는 클라이언트 구성을 단순화하고 수동 설정의 오류 가능성을 줄입니다.
    
- **동적 클라이언트 등록 (DCR):** 프로토콜은 RFC7591을 지원하여 클라이언트가 새로운 서버에 자동으로 등록할 수 있도록 권장합니다. 이는 동적인 생태계에서 원활한 사용자 경험을 위해 중요합니다.17 다만, 로드맵에서는 운영상의 어려움으로 인해 대안을 모색 중이라고 언급하고 있습니다.
    
- **위임된(Third-Party) 권한 부여:** 사양은 MCP 서버가 업스트림 서비스(예: Google, GitHub)에 대한 OAuth 클라이언트 역할을 하는 흐름을 정의합니다. 이 모델에서 <u>MCP 서버는 업스트림 서비스로부터 토큰을 획득한 후, MCP 클라이언트에게는 더 좁은 범위의 자체 토큰을 발급</u>합니다. 이는 보안 경계를 생성하여 클라이언트가 업스트림 서비스에 대한 광범위한 접근 권한을 획득하는 것을 방지하고, 최소 권한 원칙을 강제하는 효과적인 방법입니다.
    
- **엔터프라이즈 통합:** 이 모델은 기업의 SSO(Single Sign-On) 및 IdP(Identity Provider)와 통합되도록 명시적으로 설계되어, 기업 환경의 핵심 요구사항을 충족합니다.

OAuth 2.1 흐름의 공식화는 MCP를 실행 가능한 엔터프라이즈 기술로 만드는 가장 중요한 단계입니다. 이는 보안을 구현별 부가 기능이 아닌 프로토콜의 핵심적이고 표준화된 부분으로 격상시킵니다. 특히 위임된 권한 부여 패턴은 '폭발 반경(blast radius)'을 제한하는 핵심 보안 문제를 해결하므로 매우 통찰력 있는 설계라 할 수 있습니다.


**표 2: 엔터프라이즈 인증 및 권한 부여 흐름 (OAuth 2.1)**

|**단계**|**작업**|**수행 주체**|**프로토콜/메커니즘**|**핵심 내용**|
|---|---|---|---|---|
|1. 검색|MCP 서버의 권한 부여 엔드포인트 검색|MCP 클라이언트|RFC8414 (Server Metadata)|클라이언트는 `/.well-known/oauth-protected-resource`를 쿼리하여 서버의 메타데이터를 가져옴|
|2. 클라이언트 등록|MCP 서버의 인증 서버에 클라이언트 등록|MCP 클라이언트|RFC7591 (DCR)|동적으로 클라이언트를 등록하여 `client_id`를 획득 (선택적)|
|3. 사용자 권한 부여|사용자를 인증 서버로 리디렉션하여 로그인 및 동의 요청|클라이언트, 사용자, 인증 서버|OAuth 2.1 Authorization Code Flow|사용자는 요청된 범위(scope)에 동의하고, 클라이언트는 권한 부여 코드를 받음|
|4. 토큰 교환|권한 부여 코드를 액세스 토큰과 교환|MCP 클라이언트, 인증 서버|PKCE|클라이언트는 코드를 토큰 엔드포인트로 전송하여 액세스 토큰 및 리프레시 토큰을 획득|
|5. 인증된 요청|보호된 리소스에 액세스하기 위해 액세스 토큰 사용|MCP 클라이언트, MCP 서버|HTTP Bearer Token|클라이언트는 모든 요청의 `Authorization` 헤더에 베어러 토큰을 포함하여 MCP 서버에 전송|
|6. 토큰 갱신|액세스 토큰이 만료되면 리프레시 토큰을 사용하여 새 토큰 획득|MCP 클라이언트, 인증 서버|OAuth 2.1 Refresh Token|세션을 유지하기 위해 새로운 액세스 토큰을 발급받음|

### 2.2. 위협 모델링 및 고급 공격 벡터 분석

MCP의 강력함은 새로운 위협을 동반합니다. 보안 연구원들은 MCP 생태계에 특화된 여러 심각한 취약점을 식별했으며, 이에 대한 이해는 방어 전략 수립의 첫걸음입니다.8

- **도구 중독(Tool Poisoning):** 이는 MCP에 가장 특화되고 위험한 위협으로 간주됩니다. 공격자는 악의적인 MCP 서버를 통해 사용자에게는 보이지 않지만 LLM 에이전트에게는 보이는 숨겨진 지침을 도구 설명(docstring)에 포함시킵니다. LLM은 이 설명을 신뢰하고 악의적인 명령을 그대로 실행하게 됩니다. 이 공격에는 여러 변종이 존재합니다.

    - **라인 점핑(Line Jumping):** 악의적인 지침이 합법적인 도구 호출보다 _먼저_ 실행되도록 배치하는 기법입니다.
    - **전체 스키마 중독(Full-Schema Poisoning, FSP):** 공격 표면을 단순한 `description` 필드를 넘어 매개변수 이름, 유형, `required` 필드 등 도구의 전체 JSON 스키마로 확장합니다.
    - **고급 도구 중독 공격(Advanced Tool Poisoning Attack, ATPA):** 도구의 _출력_ 을 조작하여 LLM을 속이는 2차 공격을 유도합니다. 예를 들어, "오류 해결을 위해" 민감한 파일을 읽도록 유도하는 프롬프트를 도구 출력에 포함시키는 방식입니다.

- **도구 섀도잉/하이재킹(Tool Shadowing/Hijacking):** 악의적인 서버가 신뢰할 수 있는 서버의 도구를 "그림자처럼" 따라다니며 하이재킹하는 공격입니다. 예를 들어, 가짜 "계산기" 도구가 신뢰할 수 있는 "이메일" 도구를 통해 전송되는 모든 이메일을 가로채 공격자에게 전달하도록 <u>숨겨진 지침을 포함</u>할 수 있습니다.
    
- **혼란된 대리인 문제(Confused Deputy Problem):** 높은 권한을 가진 MCP 서버가 <u>낮은 권한을 가진 사용자의 요청에 속아 대신 작업을 수행</u>함으로써 최소 권한 원칙을 위반하는 고전적인 보안 문제입니다. 표준화된 OAuth 흐름은 이 문제에 대한 주요 완화책입니다.
    
- **공급망 및 레지스트리 위험:** 검증되지 않은 공개 MCP 서버 레지스트리는 악성 코드 배포의 벡터가 될 수 있습니다. 사용자가 신뢰할 수 없는 출처에서 <u>악성 서버를 설치할 위험</u>이 존재합니다.29 이는 코드 서명 및 패키지 ID 검증과 같은 공급망 보안 조치의 필요성을 강조합니다.
    

이러한 위협의 핵심은 인간 사용자가 보는 것과 LLM 에이전트가 처리하는 것 사이의 **의미론적 격차(semantic gap)** 를 악용하는 데 있습니다. 공격자들은 LLM이 추론에 사용하는 메타데이터 계층(도구 스키마)을 오염시킵니다. 이는 에이전트 시스템의 근본적인 문제이며, MCP의 표준화된 구조는 이를 예측 가능한 공격 대상으로 만듭니다.

### 2.3. 방어 아키텍처 및 완화 전략

MCP 배포를 보호하기 위해서는 전통적인 보안 제어를 넘어서는 심층 방어(defense-in-depth) 접근 방식이 필요합니다.

- **클라이언트 측 방어:** 클라이언트는 서버가 제공하는 메타데이터를 맹목적으로 신뢰해서는 안 됩니다. <u>도구 설명을 정제(sanitize)하고 검증하여 의심스러운 지침을 제거하거나 플래그를 지정</u>해야 합니다. 또한, 사용자가 수행되는 작업을 명확하게 인지하고 제어할 수 있도록 UI/UX를 설계하는 것이 중요합니다.
- **서버 측 방어:** <u>서버는 강력한 인증 및 권한 부여 메커니즘</u>을 구현해야 합니다. 또한, 커맨드 인젝션과 같은 전통적인 취약점으로부터 코드를 강화해야 합니다.
- **아키텍처 방어 (AI 게이트웨이):** 배포 규모가 커짐에 따라 **AI 게이트웨이**가 중앙 집중식 정책 시행 지점 역할을 할 수 있습니다. 이는 <u>인증, 권한 부여, 속도 제한, 캐싱 및 트래픽 관리를 처리하여 보안 로직을 중앙 집중화하고 서버 개발을 단순화</u>합니다.11
- **런타임 감사 및 정책 시행:** 도구 호출에서 비정상적인 패턴(예: 갑자기 파일 접근을 요청하는 도구)을 지속적으로 모니터링해야 합니다. Cerbos와 같은 정책 엔진을 사용하여 런타임에 세분화된 속성 기반 접근 제어(RBAC/ABAC)를 적용하고, 특정 조건 하에서 어떤 사용자에게 어떤 도구를 사용할 수 있는지 결정할 수 있습니다.
- **샌드박싱 및 격리:** MCP 서버를 <u>최소한의 권한만 가진 격리된 환경(컨테이너, VM)에서 실행</u>하여 침해 사고 발생 시 피해 범위를 제한해야 합니다.

이러한 정교한 위협과 다층적 방어 전략의 등장은 "AI 방화벽"이라는 새로운 보안 범주의 출현을 예고합니다. 이는 단순한 웹 애플리케이션 방화벽(WAF)이나 API 게이트웨이가 아니라, AI와 도구 간 통신의 의미론적 내용을 검사하고 제어하도록 특별히 설계된 보안 계층입니다. 전통적인 방화벽이 네트워크(L3/L4) 및 애플리케이션(L7) 계층에서 작동하며 알려진 공격 시그니처를 검사하는 반면, 도구 중독과 같은 MCP 위협은 더 높은 의미론적 계층에서 작동합니다. JSON-RPC 페이로드는 구문적으로는 완벽하게 유효할 수 있지만, LLM에 대한 그 _의미_ 가 악의적일 수 있습니다. 이를 방어하기 위한 도구 스키마의 정적 분석이나 비정상적 행동에 대한 런타임 감사와 같은 완화책은 통신의 _의도_ 를 이해해야 합니다. 따라서 "AI 방화벽"은 게이트웨이에서 <span style="background:#fff88f">심층적인 의미론적 검사를 수행</span>해야 할 것입니다. 예를 들어, 주 에이전트에게 정보를 전달하기 전에 숨겨진 프롬프트나 악의적인 의도가 있는지 분석하기 위해 또 다른 "가드레일" LLM을 사용할 수 있습니다.30 이는 보안 인프라가 구문적 검증에서 의미론적 검증으로 진화하는 근본적인 변화를 나타내며, MCP와 같은 프로토콜 위에 구축된 자율 에이전트 생태계를 보호하기 위한 필수적인 단계입니다.

**표 3: MCP 공격 벡터 분석 및 완화 프레임워크**

|**위협 벡터**|**설명**|**공격 표면**|**잠재적 영향**|**완화 전략 (클라이언트)**|**완화 전략 (서버/아키텍처)**|
|---|---|---|---|---|---|
|도구 중독 (FSP, ATPA)|도구 설명/스키마/출력에 악성 지침을 삽입하여 LLM을 조종|`tools/list` 응답의 JSON 스키마, `tool/result` 응답|데이터 유출, 무단 작업 수행, 원격 코드 실행|도구 설명 정제 및 검증, UI에서 전체 설명 표시, 사용자 승인 강화|AI 게이트웨이에서 스키마 검증, 런타임 이상 행위 탐지(ATPA), 최소 권한 원칙 적용|
|도구 섀도잉|악성 서버가 신뢰할 수 있는 서버의 도구 동작을 하이재킹|`tools/list` 응답의 도구 설명|신뢰할 수 있는 도구를 통한 데이터 유출 또는 작업 조작|신뢰할 수 있는 서버 소스만 허용, 도구 네임스페이스 충돌 감지|서버 레지스트리에서 서명 및 출처 확인, 게이트웨이에서 정책 기반 라우팅|
|공급망 공격|악성 MCP 서버가 레지스트리나 비공식 채널을 통해 배포됨|MCP 서버 설치 파일, 레지스트리|시스템 침해, 영구적인 백도어 설치|신뢰할 수 있는 레지스트리만 사용, 서버 코드 검토|코드 서명 의무화, 패키지 ID 검증, 레지스트리 보안 강화|
|혼란된 대리인|낮은 권한의 사용자가 높은 권한의 서버를 속여 작업을 수행|권한 부여 및 인증 메커니즘|권한 상승, 무단 리소스 접근|-|OAuth 2.1 기반의 강력한 인증/권한 부여, 위임된 권한 부여 패턴 사용|
|서비스 거부(DoS)|과도한 요청이나 자율 에이전트 루프로 서버를 마비시킴|`tool/invoke` 및 기타 서버 엔드포인트|서비스 중단, 리소스 고갈|클라이언트 측 속도 제한 구현|AI 게이트웨이에서 중앙 집중식 속도 제한, 서킷 브레이커 패턴 적용|

## Section 4: 보안 및 신뢰를 위한 기능적 메커니즘

MCP는 외부 시스템과의 연동, 임의 코드 실행 등 강력한 기능을 제공하는 만큼, 시스템의 안정성과 데이터 보안을 보장하기 위한 다층적인 기능적 장치를 내장하고 있다. 이 보안 모델은 프로토콜 자체의 강제성과 애플리케이션 구현체의 책임을 결합한 형태를 띤다.

### 4.1 핵심 원칙: 사용자 동의와 제어권

MCP 보안 모델의 최상위 원칙은 모든 <u>민감한 작업에 대한 최종 제어권을 사용자에게 부여</u>하는 것이다. 이는 프로토콜이 기술적으로 무언가를 강제하기보다는, 클라이언트를 구현하는 호스트 애플리케이션(IDE, 채팅 앱 등)이 사용자에게 명확한 선택권과 투명성을 제공해야 한다는 철학에 기반한다.2

이 원칙은 **Human-in-the-Loop 메커니즘**을 통해 구체화된다. 도구를 실행하거나, 로컬 파일에 접근하거나, LLM 샘플링을 요청하는 등 잠재적으로 위험하거나 비용이 발생할 수 있는 모든 작업 이전에, 호스트 애플리케이션은 반드시 사용자에게 명시적인 동의를 구하는 UI를 제공해야 한다.2 예를 들어, VS Code에서 MCP 도구가 실행될 때, 사용자는 해당 도구의 실행을 승인할지 묻는 확인 프롬프트를 받게 된다. 사용자는 이 승인을 일회성으로 할 수도 있고, 현재 세션, 현재 작업 공간, 또는 향후 모든 호출에 대해 영구적으로 자동 승인할 수도 있다. 이처럼 사용자에게 제어권을 넘겨주는 방식은 강력한 기능의 오용과 의도치 않은 부작용을 막는 가장 중요한 1차 방어선 역할을 한다.

### 4.2 스키마 기반 유효성 검사 및 샌드박싱

MCP는 데이터의 구조적 무결성을 보장하고 각 컴포넌트를 격리하여 보안을 강화한다.

- **스키마의 역할:** 모든 `Tool` 프리미티브는 `inputSchema`와 선택적으로 `outputSchema`를 JSON Schema 형식으로 정의할 수 있다.9 이는 단순한 문서화를 넘어, 클라이언트와 서버가 데이터를 주고받을 때 해당 데이터의 <u>구조와 타입이 약속된 형식을 따르는지 런타임에 검증</u>하는 강력한 수단이다. 클라이언트는 서버에 요청을 보내기 전에 `inputSchema`에 맞춰 인자를 검증할 수 있고, 서버는 응답을 보내기 전에 `outputSchema`에 맞춰 결과물의 유효성을 확인할 수 있다. 이를 통해 예기치 않은 입력으로 인한 서버의 오작동이나 악의적인 데이터 주입 공격의 위험을 크게 줄일 수 있다.
    
- **아키텍처 기반 샌드박싱:** MCP의 3단계(호스트-클라이언트-서버) 아키텍처는 그 자체로 자연스러운 보안 경계를 형성한다. 서버는 호스트 애플리케이션의 전체 컨텍스트나 다른 서버의 데이터에 직접 접근할 수 없다. 서버가 접근할 수 있는 정보는 오직 클라이언트를 통해 명시적으로 전달된 요청 파라미터뿐이다. 이는 각 도구(서버)를 다른 도구로부터 격리된 샌드박스에서 실행하는 것과 유사한 효과를 제공하여, 하나의 서버에 보안 취약점이 발생하더라도 그 영향이 시스템 전체로 확산되는 것을 방지한다.
    

### 4.3 인증 및 권한 부여(Authorization)

MCP는 특정 인증 방식을 강제하지 않지만, 특히 원격 서버와의 안전한 통신을 위해 표준 웹 기술을 활용할 수 있는 경로를 열어두고 있다.

- **OAuth 2.1 연동:** 원격 HTTP 기반 서버의 경우, 표준 OAuth 2.1 인증 흐름을 통해 안전한 사용자 인증 및 권한 부여를 구현할 수 있다. 사용자가 원격 서버에 처음 연결을 시도하면, 클라이언트는 사용자를 해당 서비스의 OAuth 인증 페이지로 리디렉션한다. 사용자가 로그인을 하고 권한 부여에 동의하면, 발급된 액세스 토큰(access token)이 클라이언트로 전달된다. 이후 클라이언트는 모든 MCP 요청의 헤더에 이 토큰을 포함하여 서버에 전송하고, 서버는 이 토큰을 검증하여 사용자를 식별하고 허가된 범위(scopes) 내에서만 작업을 수행하도록 제한할 수 있다.
    
- **API 키 및 민감 정보 관리:** 서버가 외부 API를 호출하기 위해 API 키와 같은 민감한 정보가 필요한 경우, 이를 소스 코드에 직접 하드코딩하는 것은 심각한 보안 위험을 초래한다. MCP 사양은 이러한 정보를 `inputSchema`에 `password: true`와 같은 속성을 가진 입력 변수로 정의하거나, 서버가 실행되는 환경의 환경 변수를 통해 동적으로 주입하는 방식을 강력히 권장한다.
    

이러한 메커니즘들을 종합해 볼 때, MCP의 보안 모델은 클라우드 서비스에서 널리 사용되는 '책임 공유 모델(Shared Responsibility Model)'과 유사한 형태를 띤다. 즉, 프로토콜 자체는 스키마 유효성 검사나 명확한 통신 채널 분리와 같은 기술적인 '가드레일'을 제공하지만, 최종적인 보안 책임, 특히 사용자의 데이터와 시스템 자원에 대한 접근을 제어하고 사용자에게 위험을 알리는 책임은 호스트 애플리케이션의 구현에 크게 의존한다.2 "도구의 설명(`description`)은 신뢰할 수 없는 서버에서 온 경우 신뢰해서는 안 된다" 2는 사양의 경고는 이러한 책임 공유의 본질을 명확히 보여준다.

그러나 MCP의 강력한 확장성과 구성 가능성은 새로운 공격 벡터(Attack Vector)를 창출하기도 한다. 특히 여러 도구의 기능을 연쇄적으로 조합하는 '도구 연쇄(Tool Chaining)'를 통한 권한 상승 및 데이터 유출은 심각한 위협으로 지적된다.1 예를 들어, 공격자는 겉보기에는 무해한 '이미지 캡션 생성' 도구를 만들 수 있다. 이 도구는 내부적으로 (1) 사용자가 제공한 로컬 파일 경로를 읽는 합법적인 '파일 읽기' 도구를 호출하고, (2) 그렇게 읽어 들인 파일 내용을 외부로 전송하는 또 다른 합법적인 '웹 요청' 도구를 호출하도록 LLM을 속일 수 있다. 각 개별 도구는 허가된 권한 내에서 작동했지만, 이들의 연쇄 작용은 사용자가 의도하지 않은 데이터 유출이라는 치명적인 결과를 낳는다. 이는 개별 도구의 권한만 관리하는 것으로는 부족하며, '워크플로우 전체'의 맥락을 이해하고 제어하는 더 정교한 보안 정책이 필요함을 시사한다. 미래의 MCP 보안 솔루션은 이러한 위협에 대응하기 위해, API 게이트웨이와 유사한 'MCP 게이트웨이'나 '보안 오케스트레이터'의 형태로 발전할 가능성이 높다.15

## 섹션 3: 신뢰의 결핍: MCP 보안 환경 심층 분석

이 섹션은 기업의 채택과 사용자 신뢰에 가장 큰 위협이 되는 보안 및 개인 정보 보호 위험에 대한 철저한 분석을 제공한다. 시스템을 연결하는 프로토콜의 힘은 공격 표면을 극적으로 확장시킨다.28

### 3.1. 열린 문: 인증 및 권한 부여 실패

핵심적인 위험은 "혼란스러운 대리인(confused deputy)" 문제로, 자신의 높은 권한으로 작동하는 MCP 서버가 낮은 권한을 가진 사용자에 의해 속아 넘어감으로써 최소 권한 원칙을 위반하고 무단 작업을 수행하는 것이다.29 프로토콜의 초기 사양은 표준 인증 메커니즘을 정의하지 않아 개별 구현에 맡겨졌다.18 사양이 OAuth 2.1을 요구하도록 업데이트되었지만 30, <span style="background:#fff88f">실제 채택은 위험할 정도로 뒤처져</span> 있다. 연구원들은 인증 없이 인터넷에 노출된 수백 개의 MCP 서버를 발견했다.30 MCP는 네이티브하고 세분화된 권한 모델이 부족하다.18 접근 제어는 종종 세션 수준(전부 아니면 전무)에서 이루어지며, 데이터 읽기, 쓰기, 삭제를 구분할 수 없다. 이러한 과도한 권한 부여 접근 모델은 주요 보안 위험이다.28 MCP 서버는 종종 <u>리소스와 권한 부여 서버 역할을 결합하여 안전한 토큰 관리를 복잡하게</u> 만든다. 일반적이지만 위험한 해결책은 관리자 토큰을 사용하거나 사용자 토큰을 서버에 일반 텍스트로 저장하여 <u>자격 증명 도난의 단일 장애점</u>을 만드는 것이다.21

### 3.2. 트로이 목마: 에이전트 조작 및 도구 중독

"도구 중독(Tool Poisoning)"은 악의적인 행위자가 도구 설명을 조작하여 LLM이 도구를 오용하거나 위험한 작업을 호출하도록 속이는 새로운 공격 벡터이다.28 예를 들어, 도구 설명에 데이터 유출을 유발하는 숨겨진 지침이 포함될 수 있다.35 표준 프롬프트 주입 공격은 MCP 컨텍스트에서 증폭된다. 악의적인 프롬프트는 에이전트가 합법적인 도구를 불법적인 목적으로 사용하도록 조작할 수 있으며, 예를 들어 민감한 데이터를 읽어 다른 도구를 통해 외부 서비스로 전송할 수 있다.28 실제 사례로는 공격자가 비공개 저장소 세부 정보를 유출하기 위해 공개 GitHub 이슈 댓글에 숨겨진 지침을 삽입한 경우가 있다.30 특히 교활한 위협은 악의적인 MCP 서버가 <u>LLM이 동일한 클라이언트에 연결된 다른 합법적인 서버를 오용하도록 지시하는 "교차 서버 공격(Cross-Server Exploitation)"</u>이다. 예를 들어, "재미있는 사실" 서버가 에이전트에게 "이메일" 서버를 사용하여 스팸을 보내도록 지시할 수 있다.35

### 3.3. 공급망의 악몽: 악성 서버 및 종속성 위험

공격자는 자격 증명을 훔치기 위해 설계된 사기성 MCP 서버를 만들고 배포할 수 있다.27 더 미묘한 위협은 "러그 풀(rug pull)" 공격으로, <u>사용자가 서버를 설치하고 신뢰한 후에 합법적인 서버가 악성 코드로 업데이트</u>되는 것이다. 클라이언트에서 의무적인 버전 고정이 부족하여 이는 심각한 취약점이 된다.35 MCP 서버는 종속성을 가진 실행 가능한 코드이므로 표준 공급망 공격에 취약하다. 예를 들어, 널리 사용되는 `mcp-remote` npm 패키지에서 심각한 취약점(CVE‑2025‑6514)이 발견되었다.30 개발 파이프라인에서 적절한 SAST 및 SCA 스캐닝이 중요하지만 보편적으로 시행되지는 않는다.29 핵심적인 위험은 손상된 플러그인이나 서버가 호스트 애플리케이션의 광범위한 시스템 권한을 상속받아 최소한의 격리로 권한 상승, 데이터 변조, 허위 정보 전파를 가능하게 한다는 것이다.31

이러한 이론적 위험은 구체적인 실제 사건들을 통해 더욱 명확해진다. 다음 표는 MCP 생태계의 아키텍처적 약점이 어떻게 악용되었는지를 보여주는 주요 공개 보안 사건들을 요약한 것이다. 이는 보안이 기업 채택의 주요 장벽이라는 주장을 뒷받침하는 실질적인 증거를 제공한다.

|사건명/유형|날짜|취약점 분류|영향|노출된 근본적 약점|출처|
|---|---|---|---|---|---|
|**NeighborJack**|2025년 6월|네트워크 노출 / 인증 부재|원격 코드 실행, 호스트 시스템 장악|방화벽 없이 `0.0.0.0`에 기본 서버 바인딩; 초기 구현에서 의무적 인증 부재|30|
|**Supabase Cursor 에이전트**|2025년 중반|신뢰할 수 없는 입력을 통한 SQL 주입|전체 SQL 데이터베이스 장악, 통합 토큰 유출|권한 있는 에이전트가 신뢰할 수 없는 출처(지원 티켓)의 명령을 정제 없이 실행|30|
|**GitHub "Toxic Agent Flow"**|2025년 중반|간접 프롬프트 주입|비공개 저장소 세부 정보 열거 및 유출|에이전트가 공개된 신뢰할 수 없는 콘텐츠(이슈 댓글)에 포함된 숨겨진 지침을 수용하고 실행|30|
|**Asana MCP 데이터 유출**|2025년 6월|다중 테넌시 실패 / 데이터 격리|한 테넌트의 고객 데이터가 MCP 통합을 통해 다른 테넌트에게 접근 가능해짐|MCP 서버의 다중 테넌트 아키텍처 버그로, 안전한 데이터 분리의 어려움을 보여줌|30|
|**`mcp-remote` CVE-2025-6514**|해당 없음|소프트웨어 공급망|이 인기 있는 OAuth 지원 종속성을 사용하는 서버들의 광범위한 잠재적 손상|취약한 제3자 패키지에 대한 의존성, 전형적인 공급망 위험|30|

### 3.4. 완화 프레임워크: 엔터프라이즈급 보안을 향하여

이러한 위협에 대응하기 위해 다층적인 보안 접근 방식이 필수적이다. **아키텍처 제어** 측면에서는 <span style="background:#fff88f">모든 통신에 TLS</span>를 강제하고, <span style="background:#fff88f">방화벽을 사용하여 MCP 서버를 중요한 내부 시스템과 분리</span>하며, <span style="background:#fff88f">로컬 서버를 샌드박스 환경에서 실행하여 기능을 제한</span>해야 한다.29 **신원 및 접근 관리(IAM)** 에서는 <span style="background:#fff88f">OAuth 2.0/2.1과 같은 검증된 프로토콜을 사용</span>하고, <span style="background:#fff88f">역할 기반 접근 제어(RBAC)를 시행</span>하며, 모든 에이전트 <span style="background:#fff88f">요청 뒤에 있는 사용자의 신원을 확인</span>해야 한다.

**운영 안전장치**로는 명령 주입을 방지하기 위해 모든 입력을 정제하고, <u>민감하거나 파괴적인 작업을 실행하기 전에 사용자에게 명시적인 확인을 요청</u>해야 한다.29 또한 감사 및 사고 대응을 위해 <span style="background:#fff88f">모든 서버 작업에 대한 강력하고 중앙 집중화된 로깅을 구현</span>해야 한다.29 마지막으로, **클라이언트 측 제어**를 통해 <u>"샘플링" 기능과 관련된 위험을 완화</u>해야 한다. 여기에는 사용자가 <span style="background:#fff88f">서버가 시작한 LLM 완성을 검토/거부할 수 있도록</span> 하고, <u>속도 제한을 구현하며, 비용 노출을 제어</u>하는 것이 포함된다.29

## 섹션 5: 종합 및 전략적 권장사항

이 마지막 섹션에서는 지금까지의 상세한 분석을 종합하여 MCP에 대한 전체적인 아키텍처 비전을 제시하고, 프로토콜을 사용하여 견고하고 안전하며 확장 가능한 시스템을 구축하려는 아키텍트와 개발자를 위한 실행 가능한 권장사항을 제공합니다.

### 5.1. MCP의 아키텍처 비전: 프로토콜과 실제의 종합

MCP는 두 부분으로 구성된 시스템으로 이해할 수 있습니다. 첫째는 잘 정의되고 간결한 통신 프로토콜이며, 둘째는 그 실제 적용에 필수적인 계층적 컨텍스트 관리(LCM)와 같은 정교한 아키텍처 패턴의 집합입니다. 프로토콜의 핵심 철학은 지능, 보안, 사용자 경험의 중심지를 호스트에 두는 동시에, 서버는 단순하고, 구성 가능하며, 특화된 상태를 유지하도록 하는 것입니다. 이 구조는 중앙 집중식 제어와 분산된 기능이라는 아키텍처 철학을 구현하며, 복잡한 AI 시스템을 모듈식으로 구축할 수 있는 강력한 패러다임을 제공합니다.

### 5.2. 견고하고 안전한 MCP 시스템 구현을 위한 전략적 권장사항

MCP의 아키텍처를 깊이 있게 이해한 것을 바탕으로, 각 역할의 개발자들을 위한 구체적인 전략적 권장사항을 다음과 같이 제시합니다.

- **서버 개발자를 위해:**
    
    - **단순성과 집중을 유지하십시오:** <span style="background:#fff88f">서버는 단일 책임 원칙</span>을 따라야 합니다. 하나의 서버가 너무 많은 기능을 수행하려고 시도하기보다는, 특정 도메인에 집중된 여러 개의 작은 서버를 구축하는 것이 좋습니다.
        
    - **명확한 도구 설명을 작성하십시오:** 도구의 `description` 필드는 LLM이 언제 해당 도구를 사용해야 할지 결정하는 가장 중요한 정보입니다. <span style="background:#fff88f">모호함 없이 명확하고 상세하게 작성</span>해야 합니다.
        
    - **입력값 검증을 철저히 하십시오:** 서버는 클라이언트로부터 받은 모든 입력값을 신뢰해서는 안 됩니다. 스키마 검증을 포함한 엄격한 <span style="background:#fff88f">입력값 검증을 구현</span>하여 예기치 않은 동작이나 보안 취약점을 방지해야 합니다.
        
    - **기능을 세분화하여 노출하십시오:** 가능한 한 기능을 <span style="background:#fff88f">세분화된 도구로 노출</span>하여 호스트가 최소 권한 원칙에 따라 필요한 기능만 선택적으로 사용할 수 있도록 하십시오.
        
- **호스트/에이전트 개발자를 위해:**
    
    - **오케스트레이션 및 보안 로직에 집중적으로 투자하십시오:** 시스템의 전반적인 지능과 안전성은 호스트의 구현 품질에 달려 있습니다. <span style="background:#fff88f">컨텍스트 집계, LLM과의 상호작용, 사용자 동의 흐름에 대한 로직</span>을 견고하게 구축해야 합니다.
        
    - **계층적 컨텍스트 관리(LCM)와 같은 명확한 전략을 구현하십시오:** 여러 서버로부터 컨텍스트를 집계하고 우선순위를 정하는 <span style="background:#fff88f">명확한 규칙을 수립</span>하십시오. LCM은 토큰 제한을 관리하고 프롬프트 품질을 유지하는 데 효과적인 패턴입니다.
        
    - **명확한 사용자 동의 및 확인 흐름을 설계하십시오:** 특히 파일 시스템을 수정하거나 외부 서비스에 데이터를 전송하는 등 부작용이 있는 도구를 실행하기 전에는, 사용자에게 수행될 작업을 명확히 알리고 명시적인 확인을 받는 UI를 반드시 구현해야 합니다.
        
    - **네임스페이스 충돌 해결 메커니즘을 개발하십시오:** 여러 서버에서 동일한 이름의 도구를 제공할 경우를 대비하여, 접두사 추가나 사용자 선택 인터페이스와 같은 충돌 해결 전략을 마련해야 합니다.
        
- **시스템 아키텍트를 위해:**
    
    - **MCP를 아키텍처 철학으로 이해하십시오:** MCP를 채택하는 것은 단순히 통신 프로토콜을 사용하는 것을 넘어, <span style="background:#fff88f">중앙 집중식 제어와 분산된 기능이라는 아키텍처 철학</span>을 받아들이는 것입니다. 시스템 설계 초기부터 호스트 구현의 복잡성을 계획에 포함시켜야 합니다.
        
    - **신뢰 경계를 명확히 정의하십시오:** <span style="background:#fff88f">호스트는 신뢰할 수 있는 코드</span>로 간주되지만, 각 서버는 잠재적으로 신뢰할 수 없는 코드로 취급해야 합니다. 호스트는 <u>각 서버의 권한을 최소화하고, 모든 상호작용을 검증하며, 사용자 데이터를 보호</u>하는 책임을 져야 합니다.
        
    - **생태계의 성숙도를 고려하십시오:** MCP는 빠르게 발전하고 있지만, 여전히 새로운 표준입니다. 특정 기능(예: 세션 간 영속성)에 대한 표준화된 해결책이 부족할 수 있음을 인지하고, 이러한 부분을 애플리케이션 수준에서 어떻게 해결할지 미리 계획해야 합니다.
        

결론적으로, Model Context Protocol은 AI 에이전트와 외부 세계를 연결하는 강력하고 유연한 표준을 제공합니다. 그러나 그 잠재력을 최대한 활용하고 안전성을 보장하기 위해서는 프로토콜의 명시적인 규칙뿐만 아니라, 그 이면에 있는 아키텍처적 원칙과 구현자에게 위임된 책임의 무게를 깊이 이해하는 것이 필수적입니다.




## 마치며


> 본 포스트는 Google Gemini의 응답을 기반으로 저의 의견을 반영하여 다시 작성했습니다.