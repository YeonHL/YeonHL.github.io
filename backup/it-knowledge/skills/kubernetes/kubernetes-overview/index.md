---
title: (Kubernetes) 개요
description: 컨테이너화된 워크로드와 서비스를 관리하는 이식 및 확장 가능한 오픈소스 플랫폼으로, 선언적 구성과 자동화를 모두 지원합니다.
date: 2025-04-22 23:14:00+0900
lastmod: 2025-04-22
slug: overview
comments: true
math: false
tags:
  - Kubernetes
keywords:
  - Kubernetes
---

![](kubernetes-intro.svg)

쿠버네티스는 컨테이너화된 애플리케이션을 자동으로 배포, 스케일링 및 관리해주는 오픈소스 시스템입니다. k8s라고도 부릅니다. 프로덕션 환경에서는 애플리케이션을 실행하는 컨테이너를 관리하고 가동 중지 시간이 없는지 확인해야 합니다. 예를 들어 컨테이너가 다운되면 다른 컨테이너를 다시 시작해야 합니다. 이를 시스템으로 처리하기 위한 것이 쿠버네티스입니다.

## 주요 기능

**자동화된 롤아웃과 롤백**

배포 시 애플리케이션을 모니터링해서 모든 인스턴스가 동시에 종료되지 않도록 보장합니다. 만약 문제가 발생하면 쿠버네티스는 변경 사항을 롤백합니다.

**자가 치유**

실패한 컨테이너를 재시작하고, 노드가 죽는 경우 컨테이너들을 교체하기 위해 다시 스케줄링 합니다. 사용자가 정의한 상태 체크에 응답하지 않는 컨테이너를 종료시키며, 서비스 준비 완료 전까지 해당 컨테이너를 클라이언트에 알리지 않습니다.

**서비스 디스커버리와 로드 밸런싱**

DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있습니다. Pod에 고유 IP 주소와 파드 집합에 대한 단일 DNS 명을 부여하고, 그 사이에서 로드 밸런싱을 수행할 수 있습니다. 컨테이너에 대한 트래픽이 많으면, 네트워크 트래픽을 로드 밸런싱하여 안정적으로 배포합니다.

**IPv4/IPv6 이중 스택**

파드와 서비스에 IPv4와 IPv6 주소를 할당할 수 있습니다.

**자동 빈 패킹(bin packing)**

컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공합니다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시합니다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 돕습니다.

리소스 요구 사항과 기타 제약 조건에 따라 컨테이너를 자동으로 배치하지만, 가용성은 그대로 유지합니다. 활용도를 높이고 더 많은 리소스를 절약하기 위해 중요한(critical) 워크로드와 최선의(best-effort) 워크로드를 혼합합니다.

[**Horizontal 스케일링**](https://kubernetes.io/ko/docs/tasks/run-application/horizontal-pod-autoscale/)

간단한 명령어나 UI를 통해서 또는 CPU 사용량에 따라 자동으로 애플리케이션의 스케일을 업 또는 다운합니다.

### 관리

[**스토리지 오케스트레이션**](https://kubernetes.io/ko/docs/concepts/storage/persistent-volumes/)

쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재할 수 있습니다. 로컬 스토리지, [AWS](https://aws.amazon.com/products/storage/)나 [GCP](https://cloud.google.com/storage/)와 같은 퍼블릭 클라우드 공급자 또는 NFS, iSCSI, Ceph, Cinder와 같은 네트워크 스토리지 시스템에서 원하는 스토리지 시스템을 자동으로 마운트합니다.

[**시크릿과 구성 관리**](https://kubernetes.io/ko/docs/concepts/configuration/secret/)

쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리할 수 있습니다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트할 수 있습니다.


[**배치 실행**](https://kubernetes.io/ko/docs/concepts/workloads/controllers/job/)

쿠버네티스는 서비스 외에도 배치(batch)와 CI 워크로드를 관리할 수 있으며, 원하는 경우 실패한 컨테이너를 교체할 수 있습니다.


[**확장성을 고려한 설계**](https://kubernetes.io/ko/docs/concepts/extend-kubernetes/)

쿠버네티스 업스트림 소스 코드 수정 없이 쿠버네티스 클러스터에 기능을 추가할 수 있습니다.

## 쿠버네티스의 철학

쿠버네티스는 전통적인, 모든 것이 포함된 Platform as a Service(PaaS)가 아닙니다. 쿠버네티스는 하드웨어 수준보다는 <span style="background:#fff88f">컨테이너 수준에서 운영</span>되기 때문에, PaaS가 일반적으로 제공하는 배포, 스케일링, 로드 밸런싱과 같은 기능을 제공하며, 사용자가 로깅, 모니터링 및 알림 솔루션을 통합할 수 있습니다. 하지만, 쿠버네티스는 모놀리식(monolithic)이 아니어서, 이런 기본 솔루션이 선택적이며 추가나 제거가 용이합니다. 쿠버네티스는 개발자 플랫폼을 만드는 구성 요소를 제공하지만, 필요한 경우 사용자의 선택권과 유연성을 지켜줍니다.

- **지원하는 애플리케이션의 유형을 제약하지 않습니다**. 쿠버네티스는 상태 유지가 필요 없는(stateless) 워크로드, 상태 유지가 필요한(stateful) 워크로드, 데이터 처리를 위한 워크로드를 포함해서 극단적으로 다양한 워크로드를 지원하는 것을 목표로 합니다. 애플리케이션이 <span style="background:#fff88f">컨테이너에서 구동될 수 있다면, 쿠버네티스에서도 잘 동작</span>할 것입니다.
- **소스 코드를 배포하지 않으며 애플리케이션을 빌드하지 않습니다**. 지속적인 통합과 전달과 배포, 곧 CI/CD 워크플로우는 조직 문화와 취향에 따를 뿐만 아니라 기술적인 요구사항으로 결정됩니다.
- **애플리케이션 레벨의 서비스를 제공하지 않습니다**. 애플리케이션 레벨의 서비스에는 미들웨어(예, 메시지 버스), 데이터 처리 프레임워크(예, Spark), 데이터베이스(예, MySQL), 캐시 또는 클러스터 스토리지 시스템(예, Ceph) 등이 있습니다. 이런 컴포넌트는 쿠버네티스 상에서 구동될 수 있고, 쿠버네티스 상에서 구동 중인 애플리케이션이 [Open Service Broker](https://openservicebrokerapi.org/)와 같은 이식 가능한 메커니즘을 통해 접근할 수 있습니다.
- **로깅, 모니터링 또는 경보 솔루션을 포함하지 않습니다**. 개념 증명을 위한 일부 통합이나, 메트릭을 수집하고 노출하는 메커니즘을 제공합니다.
- **기본 설정 언어/시스템(예, Jsonnet)을 제공하거나 요구하지 않습니다**. 선언적 명세의 임의적인 형식을 목적으로 하는 선언적 API를 제공합니다.
- **포괄적인 머신 설정, 유지보수, 관리, 자동 복구 시스템을 제공하거나 채택하지 않습니다**.

추가로, 쿠버네티스는 단순한 오케스트레이션 시스템이 아닙니다. 사실, 쿠버네티스는 오케스트레이션의 필요성을 없앱니다. 오케스트레이션의 기술적인 정의는 A를 먼저 한 다음, B를 하고, C를 하는 것과 같이 정의된 워크플로우를 수행하는 것입니다. 반면에, 쿠버네티스는 <font color="#245bdb">**독립적이고 조합 가능한 제어 프로세스들**</font>로 구성되어 있습니다. 이 프로세스는 지속적으로 현재 상태를 입력받은 의도한 상태로 나아가도록 합니다. A에서 C로 어떻게 갔는지는 상관이 없습니다. 중앙화된 제어도 필요치 않다. 시스템이 더 사용하기 쉬워지고, 강력해지며, 견고하고, 회복력을 갖추게 되며, 확장성이 향상됩니다.

위의 기능 중 이전에 쿠버네티스에서 사용한 기능이 있다면, 이는 쿠버네티스 자체 기능이 아닌 별도로 추가한 솔루션입니다.

## 쿠버네티스의 필요성

![배포 혁명](kubernetes-container-revolution.svg)


**1. 전통적인 배포 시대** 

초기 조직은 애플리케이션을 물리 서버에서 실행했습니다. 한 물리 서버에서 여러 애플리케이션의 리소스 한계를 정의할 방법이 없었기에, 리소스 할당의 문제가 발생했습니다. 예를 들어 물리 서버 하나에서 여러 애플리케이션을 실행하면, 리소스 전부를 차지하는 애플리케이션 인스턴스가 있다면 다른 애플리케이션의 성능이 저하될 수 있었습니다. 이에 대한 해결책으로 서로 다른 여러 물리 서버에서 각 애플리케이션을 실행할 수도 있지만, 이는 리소스가 충분히 활용되지 않는다는 점에서 확장 가능하지 않았으며, 조직이 많은 물리 서버를 유지하는 데에 높은 비용이 발생했습니다.

**2. 가상화된 배포 시대** 

위의 해결책으로 가상화가 등장했습니다. 가상화는 단일 물리 서버의 CPU에서 여러 가상 시스템 (VM)을 실행할 수 있게 합니다. 가상화를 사용하면 VM간에 애플리케이션을 격리하고 애플리케이션의 정보를 다른 애플리케이션에서 자유롭게 액세스할 수 없으므로, 일정 수준의 보안성을 제공할 수 있습니다.

가상화를 사용하면 물리 서버에서 리소스를 보다 효율적으로 활용할 수 있으며, 쉽게 애플리케이션을 추가하거나 업데이트할 수 있고 하드웨어 비용을 절감할 수 있어 더 나은 확장성을 제공합니다. 가상화를 통해 일련의 물리 리소스를 폐기 가능한(disposable) 가상 머신으로 구성된 클러스터로 만들 수 있습니다. 각 VM은 가상화된 하드웨어 상에서 자체 운영체제를 포함한 모든 구성 요소를 실행하는 하나의 완전한 머신입니다.

**3. 컨테이너 개발 시대** 

컨테이너는 VM과 유사하지만 격리 속성을 완화하여 애플리케이션 간에 운영체제(OS)를 공유합니다. 이 특징으로 컨테이너는 VM보다 가볍습니다. VM과 마찬가지로 컨테이너에는 자체 파일 시스템, CPU 점유율, 메모리, 프로세스 공간 등이 있습니다. 기본 인프라와의 종속성을 끊었기 때문에, 클라우드나 OS 배포본에 모두 이식할 수 있습니다.

컨테이너는 특히 다음 장점으로 널리 사용되고 있습니다:

- **기민한 애플리케이션 생성과 배포**: VM 이미지를 사용하는 것에 비해 컨테이너 이미지 생성이 보다 쉽고 효율적입니다.
- **지속적인 개발, 통합 및 배포**: 안정적이고 주기적으로 컨테이너 이미지를 빌드해서 배포할 수 있고 (이미지의 불변성 덕에) 빠르고 효율적으로 롤백할 수 있습니다.
- **개발과 운영의 관심사 분리**: 배포 시점이 아닌 빌드/릴리스 시점에 애플리케이션 컨테이너 이미지를 만들기 때문에, 애플리케이션이 인프라스트럭처에서 분리됩니다.
- **가시성(observability)**: OS 수준의 정보와 메트릭에 머무르지 않고, 애플리케이션의 헬스와 그 밖의 시그널을 볼 수 있습니다.
- **개발, 테스팅 및 운영 환경에 걸친 일관성**: 랩탑에서도 클라우드에서와 동일하게 구동됩니다.
- **클라우드 및 OS 배포판 간 이식성**: Ubuntu, RHEL, CoreOS, 온-프레미스, 주요 퍼블릭 클라우드와 어디에서든 구동됩니다.
- **애플리케이션 중심 관리**: 가상 하드웨어 상에서 OS를 실행하는 수준에서 논리적인 리소스를 사용하는 OS 상에서 애플리케이션을 실행하는 수준으로 추상화 수준이 높아집니다.
- **느슨하게 커플되고, 분산되고, 유연하며, 자유로운 마이크로서비스**: 애플리케이션은 단일 목적의 머신에서 모놀리식 스택으로 구동되지 않고 보다 작고 독립적인 단위로 쪼개져서 동적으로 배포되고 관리될 수 있습니다.
    - **리소스 격리**: 애플리케이션 성능을 예측할 수 있습니다.
    - **리소스 사용량**: 고효율, 고집적화하여 리소스를 사용할 수 있습니다.

> **출처**
> - [Kubernetes](https://kubernetes.io/)
> - [쿠버네티스란 무엇인가? | Kubernetes](https://kubernetes.io/ko/docs/concepts/overview/)